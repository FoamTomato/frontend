<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初探xxljob</title>
    <url>/2022/02/13/0.0.1%E5%88%9D%E6%8E%A2xxljob/</url>
    <content><![CDATA[<p><a href="http://gitee.com/xuxueli0323/xxl-job/releases">下载地址</a></p>
<p>搭建xxljob需要提前准备好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven3+</span><br><span class="line">jdk8+</span><br><span class="line">mysql5.7+</span><br></pre></td></tr></table></figure>

<h3 id="1-首先初始化SQL脚本建立必须的库和表"><a href="#1-首先初始化SQL脚本建立必须的库和表" class="headerlink" title="1.首先初始化SQL脚本建立必须的库和表"></a>1.首先初始化SQL脚本建立必须的库和表</h3><p><img src="https://img-blog.csdnimg.cn/41e36ffb828147959d17e4668e4fcde1.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-对于解压的文件分为三个模块"><a href="#2-对于解压的文件分为三个模块" class="headerlink" title="2.对于解压的文件分为三个模块"></a>2.对于解压的文件分为三个模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxl-job-admin：调度中心</span><br><span class="line">xxl-job-core：公共依赖</span><br><span class="line">xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）</span><br><span class="line">    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；</span><br><span class="line">    ：xxl-job-executor-sample-frameless：无框架版本；</span><br></pre></td></tr></table></figure>

<p>其中：xxl-job-core是需要引入的源码包后续我们可以用以下形式引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xxl-job-admin是我们的调度中心，我们只需要把这个项目单独拿出来运行就行了，下面是运行结果</p>
<p><img src="https://img-blog.csdnimg.cn/aa9e342bd215486daaa05d8783dd5f35.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>xxl-job-executor-sample-springboot是我们后续用boot可以参照的模板，当然也可以直接用来使用</p>
<h3 id="3-xxl-job-admin配置"><a href="#3-xxl-job-admin配置" class="headerlink" title="3.xxl-job-admin配置"></a>3.xxl-job-admin配置</h3><p>先修改数据库的地址，也就是上面初始化的地址</p>
<p><label style="color:#843900">注意在数据库地址哪里加上时区属性，否则乱码</label></p>
<p><img src="https://img-blog.csdnimg.cn/5f6ad4958e8940e19977bdfbd74a6d56.png#pic_center" alt="在这里插入图片描述"></p>
<p>然后修改警报邮箱配置</p>
<p><img src="https://img-blog.csdnimg.cn/fdce9d1b4aa744269bdfcd5706c83abc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-警报邮箱配置"><a href="#4-警报邮箱配置" class="headerlink" title="4.警报邮箱配置"></a>4.警报邮箱配置</h3><p><img src="https://img-blog.csdnimg.cn/f59f8bc6828343909ba1c178b8ed6e72.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>去自己对应邮箱的设置里面找到smtp并开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：spring.mail.password的密码是QQ邮箱开启SMTP的授权码而非QQ密码</span><br></pre></td></tr></table></figure>

<p><label style="color:#843900">这里需要注意不同邮箱有不同的收发件host</label></p>
<p>比如新浪</p>
<p>发件:POP3服务器为：pop3.sina.com.cn<br>收件:SMTP服务器为：smtp.sina.com.cn</p>
<p>qq</p>
<p>发件:POP3服务器为：pop.qq.com<br>收件:SMTP服务器为：smtp.qq.com</p>
<p>注意 不能自己邮箱发自己邮箱，否则收不到</p>
<p><img src="https://img-blog.csdnimg.cn/e0947d401d0f4f0d8bb6a64063f3d866.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>上面就是收件的内容</p>
<h3 id="5-boot整合xxljob"><a href="#5-boot整合xxljob" class="headerlink" title="5.boot整合xxljob"></a>5.boot整合xxljob</h3><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件整合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.executor.impl.XxlJobSpringExecutor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxlConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(xxlConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxlJobSpringExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        XxlJobSpringExecutor xxlJobSpringExecutor = <span class="keyword">new</span> XxlJobSpringExecutor();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动端口和访问路径</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8089</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/todo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 调度中心（xxl-job-admin）的部署地址，如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；</span></span><br><span class="line"><span class="comment"># 为空则关闭自动注册；则需要手动注册</span></span><br><span class="line"><span class="meta">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="meta">xxl.job.accessToken</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="meta">xxl.job.executor.appname</span>=<span class="string">job-to-do</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="meta">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="meta">xxl.job.executor.ip</span>=<span class="string"></span></span><br><span class="line"><span class="meta">xxl.job.executor.port</span>=<span class="string">9998</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="meta">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="meta">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<h3 id="6-定时任务的创建方式"><a href="#6-定时任务的创建方式" class="headerlink" title="6.定时任务的创建方式"></a>6.定时任务的创建方式</h3><p><img src="https://img-blog.csdnimg.cn/20210107153914491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ajc3NjE5OTg0NQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>@XxlJob注解是新版本提供的方式，不需要继承</p>
<p>旧版方式是继承IJobHander然后重写execute方法</p>
<h3 id="7-界面介绍"><a href="#7-界面介绍" class="headerlink" title="7.界面介绍"></a>7.界面介绍</h3><p><img src="https://img-blog.csdnimg.cn/1d7d97d8e07041649fe41609182ff877.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/64509e90b93641e38373b498c1f68392.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><label style="color:#843900"> 注意  当删除任务时，任务日志也会跟着删除 </label></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>分段执行</title>
    <url>/2022/05/01/0.0.3%E5%88%86%E6%AE%B5%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(dataList.size() &lt;= batchSize)&#123;</span><br><span class="line">    insertByStocks(dataList,type);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dataList.size();i+=batchSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i + batchSize)&gt; dataList.size())&#123;</span><br><span class="line">            batchSize = dataList.size()-i;</span><br><span class="line">        &#125;</span><br><span class="line">        insertByStocks(dataList.subList(i,i+batchSize),type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>batchSize: 每次执行多少条</p>
<p>dataList:  数据列表</p>
<p>insertByStocks：需要执行的方法</p>
]]></content>
      <tags>
        <tag>工具类</tag>
        <tag>算法公式</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表思想</title>
    <url>/2022/04/10/0.0.4%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<blockquote>
<p>随着单库中的数据量越来越大、数据库的查询QPS越来越高，相应的，对数据库的读写所需要的时间也越来越多。数据库的读写性能可能会成为业务发展的瓶颈。对应的，就需要做数据库性能方面的优化。</p>
</blockquote>
<p>场景一：<code>如果数据库的查询QPS【连接数】过高，就需要考虑拆库</code>，通过分库来分担单个数据库的连接压力。比如，如果查询QPS为3500，假设单库可以支撑1000个QPS的话，那么就可以考虑拆分成4个库，来分散查询连接压力。</p>
<p>场景二：<code>如果单表数据量过大，就需要考虑分表</code>，当数据量超过一定量级后，无论是对于数据查询还是数据更新，在经过索引优化等纯数据库层面的传统优化手段之后，还是可能存在性能问题。这是量变产生了质变，这时候就需要去换个思路来解决问题，比如：从数据生产源头、数据处理源头来解决问题，既然数据量很大，那我们就来个分而治之，化整为零。这就产生了分表，把数据按照一定的规则拆分成多张表，来解决单表环境下无法解决的存取性能问题。</p>
<p>场景三：<code>如果单数据库宕机，可能所有数据都会丢失，就需要考虑数据拆分</code></p>
<ul>
<li>单库部署情况下，如果数据库宕机，那么故障影响就是100%，而且恢复可能耗时很长。</li>
<li>如果我们拆分成2个库，分别部署在不同的机器上，此时其中1个库宕机，那么故障影响就是50%，还有50%的数据可以继续服务。</li>
<li>如果我们拆分成4个库，分别部署在不同的机器上，此时其中1个库宕机，那么故障影响就是25%，还有75%的数据可以继续服务，恢复耗时也会很短。</li>
</ul>
<p>当然，我们也不能无限制的拆库，这也是牺牲存储资源来提升性能、可用性的方式，毕竟资源总是有限的。</p>
<h2 id="分库分表是什么"><a href="#分库分表是什么" class="headerlink" title="分库分表是什么"></a>分库分表是什么</h2><p><code>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题</code>，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</p>
<h2 id="分库分表有哪些"><a href="#分库分表有哪些" class="headerlink" title="分库分表有哪些"></a>分库分表有哪些</h2><p>分库分表包括分库和分表两个部分，在生产中通常包括：垂直分表、垂直分库、水平分库、水平分表四种方式</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>在电商的场景中，商品往往只会在用户感兴趣的时候才会查看该商品的详细描述，因此，商品信息中商品详情访问的频率没有那么高，而且一般占用的内存空间会较大，访问单个数据IO时间较长</p>
<p>反之，商品名称，图片和价格等这些关键性字段的访问频率较高。</p>
<p>针对这两种数据的特性，我们可以考虑进行垂直分表，访问频率低的商品详情单独拆分为一张表，访问频率高的字段放在一张表，通过商品的id进行关联</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220409012707355.png/" alt="image-20220409012707355"></p>
<p><strong>垂直分表定义：将一个表按照字段分成多表，每个表存储其中一部分字段</strong></p>
<p>优点：</p>
<ul>
<li>为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响 </li>
<li>充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累</li>
</ul>
<p>一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的<strong>商品描述</strong>。所以，当表数据量很大时，可以<strong>将表按字段切开，将热门字段、冷门字段分开放置在不同库中</strong>，这些库可以放在不同的存储设备上，避免IO争抢。</p>
<p>垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</p>
<p>通常我们按以下原则进行垂直拆分：</p>
<ul>
<li>把不常用的字段单独放在一张表</li>
<li>把text，blob等大字段拆分出来放在附表中</li>
<li>经常组合查询的列放在一张表中</li>
</ul>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>通过垂直分表性能得到了一定程度的提升，但是还没有达到要求，并且磁盘空间也快不够了，因为数据还是始终限制在一台服务器，<code>库内垂直分表只解决了单一表数据量过大的问题</code>，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。 </p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220410141146891.png/" alt="image-20220410141146891"></p>
<p><strong>垂直分库定义：按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用</strong></p>
<p>优点：</p>
<ul>
<li>解决业务层面的耦合，业务清晰</li>
<li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈 </li>
</ul>
<p>垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到<code>多个服务器共同分摊压力</code>的效果，但是依然没有解决单表数据量过大的问题</p>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>经过<strong>垂直分库</strong>后，数据库性能问题得到一定程度的解决，但是随着业务量的增长，PRODUCT_DB(商品库)单库存储数据已经超出预估。粗略估计，目前有8w店铺，每个店铺平均150个不同规格的商品，再算上增长，那商品数量得往1500w+上预估，并且PRODUCT_DB(商品库)属于访问非常频繁的资源，单台服务器已经无法支撑。此时该如何优化？</p>
<p>这时候我们需要考虑使用水平分库，通过分库规则将商品信息分别放在两个库中</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220410141729502.png/" alt="image-20220410141729502"></p>
<p>也就是说，要操作某条数据，先分析这条数据所属的店铺ID。如果店铺ID为双数，将此操作映射至RRODUCT_DB1(商品库1)；如果店铺ID为单数，将操作映射至RRODUCT_DB2(商品库2)。此操作要访问数据库名称的表达式为<strong>RRODUCT_DB[店铺ID%2 + 1]</strong> 。</p>
<p> <strong>水平分库定义：是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上</strong></p>
<p>优点：</p>
<ul>
<li>解决了单库大数据，高并发的性能瓶颈</li>
<li>提高了系统的稳定性及可用性</li>
</ul>
<p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行<strong>水平分库</strong>了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度</p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>按照水平分库的思路对他把PRODUCT_DB_X(商品库)内的表也可以进行水平拆分，其目的也是为解决单表数据量大的问题</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220410142038513.png/" alt="image-20220410142038513"></p>
<p>与水平分库的思路类似，不过这次操作的目标是表，商品信息及商品描述被分成了两套表。</p>
<p>如果商品ID为双数，将此操作映射至商品信息1表；如果商品ID为单数，将操作映射至商品信息2表。此操作要访问表名称的表达式为<strong>商品信息[商品ID%2 + 1]</strong> </p>
<p> <strong>水平分表定义：在同一个数据库内，把同一个表的数据按一定规则拆到多个表中</strong></p>
<p>优点：</p>
<ul>
<li>优化单一表数据量过大而产生的性能问题 </li>
<li>避免IO争抢并减少锁表的几率</li>
</ul>
<p>库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表方案，在数据量及访问压力不是特别大的情况，首先考虑缓存、读写分离、索引技术等方案。若数据量极大，且持续增长，再考虑水平分库水平分表方案，因为它也会带来一些问题：</p>
<ul>
<li><p>事务一致性问题</p>
<blockquote>
<p>由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来<strong>分布式事务</strong>问题</p>
</blockquote>
</li>
<li><p>跨节点关联查询</p>
<blockquote>
<p>在没有分库前，我们检索商品时可以通过以下SQL对店铺信息进行关联查询： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.<span class="operator">*</span>,r.[地理区域名称],s.[店铺名称],s.[信誉] <span class="keyword">FROM</span> [商品信息] p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [地理区域] r <span class="keyword">ON</span> p.[产地] <span class="operator">=</span> r.[地理区域编码] <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [店铺信息] s <span class="keyword">ON</span> p.id <span class="operator">=</span> s.[所属店铺] WHERE...ORDER BY...LIMIT...</span><br></pre></td></tr></table></figure>

<p>但垂直分库后**[商品信息]和[店铺信息]**不在一个数据库，甚至不在一台服务器，无法进行关联查询。 </p>
<p>可将原关联查询分为两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据，最后将获得到的数据进行拼装（归并）</p>
</blockquote>
</li>
<li><p>跨节点分页，排序函数</p>
<blockquote>
<p>跨节点多库进行查询时limit分页、order by排序等问题，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序</p>
<p>所以请求页数越大，系统的性能也会越差</p>
<p><code>在使用Max、Min、Sum、Count之类的函数进行计算的时候，与排序分页同理，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回</code></p>
</blockquote>
</li>
<li><p>主键避重</p>
<blockquote>
<p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题</p>
</blockquote>
</li>
<li><p>公共表</p>
<blockquote>
<p>实际的应用场景中，参数表、数据字典表等都是数据量较小，变动少，而且属于高频联合查询的依赖表</p>
<p><code>可以将这类表在每个数据库都保存一份，所有对公共表的更新操作都同时发送到所有分库执行</code></p>
</blockquote>
</li>
</ul>
<p>由于分库分表之后，数据被分散在不同的数据库、服务器。因此，对数据的操作也就无法通过常规方式完成，并且它还带来了一系列的问题。所以使用之前需要把以上会带来的问题仔细考虑进去</p>
]]></content>
      <tags>
        <tag>分库分表</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存双写不一致</title>
    <url>/2022/03/07/0.0.5%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h1 id="缓存数据库双写不一致"><a href="#缓存数据库双写不一致" class="headerlink" title="缓存数据库双写不一致"></a>缓存数据库双写不一致</h1><blockquote>
<p>高并发下缓存与数据库双写不一致解决方案</p>
</blockquote>
<p>正常的缓存数据库更新的时候应该是先执行线程1，然后执行线程2</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307203941385.png/" alt="image-20220307203941385"></p>
<p>如果线程1卡顿了一下，这时就会造成数据库和缓存不一致的情况<code>线程1把线程2更新的缓存数据给覆盖了</code></p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307204214243.png/" alt="image-20220307204214243"></p>
<h2 id="最开始的缓存不一致问题以及解决方案"><a href="#最开始的缓存不一致问题以及解决方案" class="headerlink" title="最开始的缓存不一致问题以及解决方案"></a>最开始的缓存不一致问题以及解决方案</h2><blockquote>
<p>问题：先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。</p>
</blockquote>
<p>解决思路：<br>　　先删除缓存，再修改数据库，如果删除缓存成功了修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307205922621.png/" alt="image-20220307205922621"></p>
<h2 id="2、并发下数据缓存不一致问题分析"><a href="#2、并发下数据缓存不一致问题分析" class="headerlink" title="2、并发下数据缓存不一致问题分析"></a><strong>2、并发下数据缓存不一致问题分析</strong></h2><p>问题：<br>　　第一个请求数据发生变更，先删除了缓存，然后要去修改数据库，此时还没来得及去修改；<br>　　第二个请求过来去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中；<br>　　第三个请求读取缓存中的数据 (此时第一个请求已经完成了数据库修改的操作)。<br>　　完了，数据库和缓存中的数据不一样了。。。。</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307210140337.png/" alt="image-20220307210140337"></p>
<p>分析原因：</p>
<p>只有在对同一条数据并发读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景;但如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。</p>
<h3 id="内存队列"><a href="#内存队列" class="headerlink" title="内存队列"></a>内存队列</h3><p>数据库的缓存更新与读取操作进行串行化，一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p>
<p>  　　1. 首先我们的项目里维护一组线程池和内存队列。<br>  　　2. 更新数据的时候，根据数据的唯一标识将请求路由到一个jvm队列中，去更新数据库,然后请求结束。<br>  　　3. 读取数据的时候，先查缓存，如果发现数据不在缓存中，那么将根据唯一标识路由之后，也发送同一个jvm内部的队列中，重新读取数据库后更新缓存,最后请求结束。</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/1363214-20190929191217957-1916614649.png/" alt="img"></p>
<p>缺点：</p>
<p>1.实现起来麻烦，不同的key可能需要搞不同的队列</p>
<p>2.如果系统挂了，还得还原这些数据，如果出现了异常，还会造成脏数据</p>
<h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307214115094.png/" alt="image-20220307214115094"></p>
<p>延时双删方案执行步骤<br>1.删除redis<br>2.更新数据库<br>3.延时50毫秒<br>4.删除redis</p>
<ul>
<li>问题一：为何要延时50毫秒？<br>这是为了我们在第二次删除redis之前能完成数据库的更新操作。<br>假象一下，如果没有第三步操作时，有很大概率，在两次删除redis操作执行完毕之后，数据库的数据还没有更新，此时若有请求访问数据，便会出现我们一开始提到的那个问题。</li>
<li>问题二: 为何要两次删除redis?<br>如果我们没有第二次删除操作，此时有请求访问数据，有可能是访问的之前未做修改的redis数据，删除操作执行后，redis为空，有请求进来时，便会去访问数据库，此时数据库中的数据已是更新后的数据，保证了数据的一致性。</li>
</ul>
<p>缺点：</p>
<p>1.没有从根本上面去解决问题，如果更新缓存时间超过50ms，那么还是失败的，如果要一直保证休眠时间大于更新时间，这样会不会造成阻塞</p>
<p>2.如果一个接口请求有限制时间，这休眠时间会影响用户体验，影响接口的响应速度</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>如果加分布式锁可以直接保证每个线程的执行顺序，也是一种串行操作</p>
<p>这个还是比较推荐使用的，比内存串行实现简单，而且稳定</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307215417929.png/" alt="image-20220307215417929"></p>
<p>缺点：</p>
<p>1.分布式锁会有性能问题，会导致并发量很低（<code>加锁永远不是最优的方案</code>）</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>redisson中间里面实现了读写锁，读锁与读锁之间是不会互斥的和没加锁一样，写锁与写锁会互斥</p>
<p>一般都是读多写少</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220307220011598.png/" alt="image-20220307220011598"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来说，就是如果你的系统<strong>不是严格要求</strong>缓存+数据库必须<strong>一致性</strong>的话，缓存可以稍微的跟数据库偶尔有不一致的情况，那最好<strong>不要</strong>上述的<strong>串行化</strong>的这个方案，因为读请求和写请求串行化，串到一个内存队列里去，这样是可以保证一定不会出现不一致的情况。但是，串行化之后，就会导致系统的<strong>吞吐量会大幅度的降低</strong>，你就需要用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>以上是本人对缓存数据库不一致情况的了解，本人能力有限，如有问题还望包含，也欢迎指正。谢谢！</p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>简单吐槽一下xml</title>
    <url>/2022/01/08/0.0.6%E7%AE%80%E5%8D%95%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8Bxml/</url>
    <content><![CDATA[<blockquote>
<p>描述</p>
</blockquote>
<p>近期与供应商对接的时候，对方的接口还是比较稳定的xml接口，与当下流行的json的便捷性相比还是不太方便，中间我也使用了几种工具类，很难有完全适配的，下文我将讲述我解析xml的历程</p>
<blockquote>
<p>初次接触</p>
</blockquote>
<p>第一次接触xml接口是在对接物流渠道商的时候，当时他们使用的对接方式为soap格式，刚接触解析起来简直要了老命，什么是soap呢？是基于xml的简易协议，常用于webservie，它有自己的一套编码规则，如下</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/20161106222250124.png/" alt="在这里插入图片描述"></p>
<p>这种请求网上解析方式就很少，很多只有解析没有构造，文本也不太全，目前见过写的比较好的解析如下：<a href="https://blog.csdn.net/RUANJIAOXIAOZI/article/details/90770534">https://blog.csdn.net/RUANJIAOXIAOZI/article/details/90770534</a></p>
<p>当然还有xsd模式的xml<br><img src="https://img-blog.csdnimg.cn/03da286e53754f9cba71647d703c0c3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>因为这次讲的是xml解析，上面只是举个栗子，让你们体会一下xml的变种有多难😭</p>
<p>这种接口不过分的说，至少十年往上的架构了</p>
<blockquote>
<p>使用dom4j/jsoup解析</p>
</blockquote>
<p>dom4j应该是最经典解析xml的api了，性能优异，功能强大。但是使用起来还是略为麻烦，有点像用java的jsoup去爬取网页，需要一个一个节点的去找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dom4j获取xml的三种方式</span><br><span class="line"><span class="number">1.</span>读取xml文件，获得document对象</span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    Document document = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;test.xml&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>直接解析xml形式的文本</span><br><span class="line">    String text = <span class="string">&quot;&lt;tag&gt;&lt;/tag&gt;&quot;</span>;</span><br><span class="line">	Document document = DocumentHelper.parseText(text);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>主动创建document对象</span><br><span class="line">    Document document = DocumentHelper.createDocument();</span><br><span class="line">	Element root = document.addElement(<span class="string">&quot;tag&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jsoup解析html方式</span><br><span class="line">Document document = Jsoup.parse(html);</span><br><span class="line">Element postList = document.getElementById(<span class="string">&quot;post_list&quot;</span>);</span><br><span class="line">Elements titleEle = postItem.select(<span class="string">&quot;.post_item_body a[class=&#x27;titlelnk&#x27;]&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上这种解析方式，属于所见即所得随时可取，但是往往可读性比较差，如图<br><img src="https://img-blog.csdnimg.cn/eabec9e14b4b4fa3b1ffb5459f8c3ca9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>当然如果你不嫌麻烦，jsoup也可以解析xml的😎</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosupTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取Document对象，根据xml文档获取</span></span><br><span class="line">        <span class="comment">//2. 获取user.xml的path</span></span><br><span class="line">        String path = Objects.requireNonNull(JosupTest.class.getClassLoader().getResource(<span class="string">&quot;User.xml&quot;</span>)).getPath();</span><br><span class="line">        <span class="comment">//3. 解析xml文档，加载文档进内存，获取dom树-----&gt;Document</span></span><br><span class="line">        Document document = Jsoup.parse(<span class="keyword">new</span> File(path),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 获取元素对象Elements(类型为ArrayList)</span></span><br><span class="line">        Elements elements = document.getElementsByTag(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 测试获取元素的个数是否符合，xml文件中的个数</span></span><br><span class="line">        System.out.println(elements.size());</span><br><span class="line">        <span class="comment">//5. 测试获取第一个元素</span></span><br><span class="line">        Element element = elements.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//5. 测试获取第一个元素的文本内容</span></span><br><span class="line">        String name = element.text();</span><br><span class="line">        <span class="comment">//5. 测试获取第一个元素的名字是否正确</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用fastjson进行转换</p>
</blockquote>
<p>fastjson和gson这两种解析方式是我使用最多的两种解析方式</p>
<p>gson：快速，高效，代码量少，面向对象，但是相对fastjson和jackjson，它的各方面性能都被碾压</p>
<p>fastjson：性能最高，支持多种类型解析，由于fastjson太侧重性能，对于部分高级特性支持不够，有一部分自定义特性完全偏离了json和js规范，可能导致与其他框架不兼容的bug，并且文档缺失较多，而且代码缺少注释较为晦涩，近几年也出现过一些高危漏洞</p>
<p>如果要使用fastjson解析xml为json格式就需要使用工具类的形式进行转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.service.zl.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentHelper;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONArray;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sleep</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-09-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlTools</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String 转 org.dom4j.Document</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DocumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">strToDocument</span><span class="params">(String xml)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DocumentHelper.parseText(xml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * org.dom4j.Document 转  com.alibaba.fastjson.JSONObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DocumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">documentToJSONObject</span><span class="params">(String xml)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elementToJSONObject(strToDocument(xml).getRootElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * org.dom4j.Element 转  com.alibaba.fastjson.JSONObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">elementToJSONObject</span><span class="params">(Element node)</span> </span>&#123;</span><br><span class="line">        JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="comment">// 当前节点的名称、文本内容和属性</span></span><br><span class="line">        List&lt;Attribute&gt; listAttr = node.attributes();<span class="comment">// 当前节点的所有属性的list</span></span><br><span class="line">        <span class="keyword">for</span> (Attribute attr : listAttr) &#123;<span class="comment">// 遍历当前节点的所有属性</span></span><br><span class="line">            result.put(attr.getName(), attr.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归遍历当前节点所有的子节点</span></span><br><span class="line">        List&lt;Element&gt; listElement = node.elements();<span class="comment">// 所有一级子节点的list</span></span><br><span class="line">        <span class="keyword">if</span> (!listElement.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element e : listElement) &#123;<span class="comment">// 遍历所有一级子节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.attributes().isEmpty() &amp;&amp; e.elements().isEmpty()) <span class="comment">// 判断一级节点是否有属性和子节点</span></span><br><span class="line">                    result.put(e.getName(), e.getTextTrim());<span class="comment">// 沒有则将当前节点作为上级节点的属性对待</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!result.containsKey(e.getName())) <span class="comment">// 判断父节点是否存在该一级节点名称的属性</span></span><br><span class="line">                        result.put(e.getName(), <span class="keyword">new</span> JSONArray());<span class="comment">// 没有则创建</span></span><br><span class="line">                    ((JSONArray) result.get(e.getName())).add(elementToJSONObject(e));<span class="comment">// 将该一级节点放入该节点名称的属性对应的值中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面工具类可以直接把xml转为json格式，非常方便，但是局限性太大   只能单向解析，所以最好的方式还是建立实体类的方式</p>
<blockquote>
<p>jaxb和jackson</p>
</blockquote>
<p>jaxb：它是一个业界的标准，是一项可以根据xml生成java类的技术。也可以根据xml实例文档反向生成java对象树的方法，与sax和dom不同，不需要了解xml解析技术，就两种操作<code>java对象转xml</code>和<code>xml转java对象</code></p>
<p>jackson：它性能介于fastjson和gson之间，但是它是目前最流行的api，规范性高，漏洞也没有fastjson多，还支持json和xml转换，目前市场上最好用的api之一</p>
<p>先来看看jaxb的解析xml方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;ServicesError&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBaoBaseRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;ErrorCode&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(String errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;ErrorMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMessage</span><span class="params">(String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jaxb的解析可以参考这篇文章：<a href="https://blog.csdn.net/wn084/article/details/80853587">https://blog.csdn.net/wn084/article/details/80853587</a></p>
<p>以下是jackjson的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.model.taobao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.MapperFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.dataformat.xml.XmlMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlRootElement;</span><br><span class="line"><span class="keyword">import</span> javax.xml.stream.XMLStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: test &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Description: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * date: 2022/1/30 9:08&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, XMLStreamException </span>&#123;</span><br><span class="line">        String xml = <span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; standalone=\&quot;no\&quot; ?&gt;&lt;DataList Airlines=\&quot;ALL\&quot; Dpt=\&quot;KMG\&quot; Arr=\&quot;JJN\&quot; Date=\&quot;20220301\&quot; Carrier=\&quot;SC\&quot; Cabin = \&quot;U\&quot; Code=\&quot;SC9260\&quot;&gt;&lt;/DataList&gt;&quot;</span>;</span><br><span class="line">        DataList dataList1 = xmlToObject(xml, DataList.class);</span><br><span class="line">        System.out.println(JSON.toJSONString(dataList1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">objectToXml</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        XmlMapper xmlMapper= <span class="keyword">new</span> XmlMapper();</span><br><span class="line">        xmlMapper.setDefaultUseWrapper(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 字段为null，自动忽略，不再序列化 */</span></span><br><span class="line">        xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        <span class="comment">/* 设置转换模式 */</span></span><br><span class="line">        xmlMapper.enable(MapperFeature.USE_STD_BEAN_NAMING);</span><br><span class="line">        String resultXml = xmlMapper.writeValueAsString(object);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultXml;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">xmlToObject</span><span class="params">(String xml,Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException, XMLStreamException </span>&#123;</span><br><span class="line">        XmlMapper xmlMapper= <span class="keyword">new</span> XmlMapper();</span><br><span class="line">        xmlMapper.setDefaultUseWrapper(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* 字段为null，自动忽略，不再序列化 */</span></span><br><span class="line">        xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        <span class="comment">/* 设置转换模式 */</span></span><br><span class="line">        xmlMapper.enable(MapperFeature.USE_STD_BEAN_NAMING);</span><br><span class="line">        <span class="keyword">return</span> xmlMapper.readValue(xml, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@JacksonXmlRootElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataList</span></span>&#123;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Airlines;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Dpt;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Arr;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Date;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Carrier;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Cabin;</span><br><span class="line">    <span class="meta">@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="keyword">private</span> String Code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAirlines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Airlines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAirlines</span><span class="params">(String airlines)</span> </span>&#123;</span><br><span class="line">        Airlines = airlines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Dpt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDpt</span><span class="params">(String dpt)</span> </span>&#123;</span><br><span class="line">        Dpt = dpt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArr</span><span class="params">(String arr)</span> </span>&#123;</span><br><span class="line">        Arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        Date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Carrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarrier</span><span class="params">(String carrier)</span> </span>&#123;</span><br><span class="line">        Carrier = carrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCabin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Cabin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCabin</span><span class="params">(String cabin)</span> </span>&#123;</span><br><span class="line">        Cabin = cabin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        Code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>里面写了一个工具类：<code>objectToXml</code>和<code>xmlToObject</code>可以转换xml和实体类<br>==注意踩坑==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">坑一：大小写问题</span><br><span class="line"></span><br><span class="line"><span class="meta">@JacksonXmlProperty(localName = &quot;Apid&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer Apid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getApid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Apid</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">把注解放在成员变量上面，会解析出两个apid字段，一个是&lt;Apid&gt;&lt;/Apid&gt;,另一个是&lt;apid&gt;&lt;apid&gt;</span><br><span class="line"></span><br><span class="line">这是因为Jackson的处理机制会自动从属性方法上获取成员变量名，然而在java中，要么以驼峰命名，要么前两个字母都大写，才能用get方法正确地获取属性，所以使用getApid获取的成员名称就是apid，被jackson解析了出来。又因为成员变量上也加了注解，所以也会被解析。这就造成了xml文件生成了两个apid标签。正确的做法是把注解写到get方法上面</span><br><span class="line"></span><br><span class="line">正确写法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer Apid;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JacksonXmlProperty(localName = &quot;Apid&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getApid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Apid</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">坑二：Jackson封装list问题</span><br><span class="line"></span><br><span class="line">这个问题排查的时候异常困难……开始以为是封装的问题…………(吐槽一下，这个外包项目使用大量xml交互，但是又用不了webservice就得按照固定格式解析封装xml.....改动也贼困难。。。)……最后还是确定了是jackson的问题</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; APID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JacksonXmlProperty(localName = &quot;APID&quot;)</span></span><br><span class="line"><span class="meta">@JacksonXmlElementWrapper(useWrapping = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getAPID</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> APID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">开始APID这个list一直被包装了两层！正确结果应该是&lt;APID&gt;<span class="number">111</span>&lt;/APID&gt;</span><br><span class="line"></span><br><span class="line">但是得到的是&lt;APID&gt;&lt;APID&gt;<span class="number">111</span>&lt;/APID&gt;&lt;/APID&gt;</span><br><span class="line"></span><br><span class="line">问题出在JacksonXmlElementWrapper</span><br><span class="line">如果不指定的话这个值默认是<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<p>目前感觉解析xml的api还是比较多的，针对xml的各种奇奇怪怪的格式，并不是都能兼容到，目前感觉最好用的还是jackson+Lombok能比较好的快速解决问题，当然要注意lombok的侵入性和jdk的版本选择最好的方式去解决，有些方式虽然不方便，但是它就是能解决问题……</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>解决微信小程序键盘上移</title>
    <url>/2022/02/16/0.0.7%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%94%AE%E7%9B%98%E4%B8%8A%E7%A7%BB/</url>
    <content><![CDATA[<p>在微信开发者工具没有出现上移的情况，但是一到真机调试就出现了，把页面设置固定布局也不管用<br><img src="https://img-blog.csdnimg.cn/ee256319d57f47979e4671c18a10ffc1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARm9hbeeVquiMhA==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后查询微信官方文档，是这样解释的<br>小程序在input框输入时，默认会开启自动上推的功能，但是有的时候会出现卡顿的现象，想关闭自动上推，把<br><label style="color:#843900">adjust-position设置为false</label>就可以了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span>  <span class="attr">gutter</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag">          <span class="attr">left-icon</span>=<span class="string">&quot;eye-o&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">adjust-position</span>=<span class="string">&quot;false&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">name</span>=<span class="string">&quot;input&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>  <span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;password&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>按道理应该就不会出现了，结果就是不生效，经过几轮瞎搞后才发现需要加<code>&#123;&#123;&#125;&#125;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span>  <span class="attr">gutter</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag">         <span class="attr">left-icon</span>=<span class="string">&quot;eye-o&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">adjust-position</span>=<span class="string">&quot;&#123;&#123; false &#125;&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">name</span>=<span class="string">&quot;input&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>  <span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;password&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请大家谨慎踩坑</p>
]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>使用redis实现分布式锁</title>
    <url>/2022/03/02/0.0.8%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>Java中提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下合理选择能展现非常高的效率</p>
</blockquote>
<p>分布式锁一般有三种实现方式：<code>数据库乐观锁</code>，<code>Redis分布式锁</code>，<code>Zookeeper分布式锁</code></p>
<p>本篇博客主要详细介绍redis分布式锁的进化，进化所解决的场景问题</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>首先，为了确保分布式锁的可用性，我们需要确保锁能同时满足以下四个条件</p>
<ol>
<li><code>互斥性</code>:在任意时刻，只有一个客户端能持有锁。</li>
<li><code>不会发生死锁</code>:即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li><code>具有容错性</code>:只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li><code>解铃还须系铃人</code>:加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在单机下可以用synchronized同步代码块加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在真实的场景下，往往是多台服务器做负载，而synchronized是进程级别的，只在当前进程有效</p>
<p>如果是做了负载的服务器，往往控制不住请求，依然会有并发问题，在并发低的情况下可能不会出现问题</p>
<p>这种情况下就得用分布式锁</p>
<p>在redis中，利用<code>setnx</code>命令的特性可以轻松实现分布式锁</p>
<blockquote>
<p>只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。</p>
<p>返回值：命令在设置成功时返回 1 ，设置失败时返回 0 。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190303135212531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhem91MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String locKey = <span class="string">&quot;lockey&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果存在则true,成功则新增返回false</span></span><br><span class="line">    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, <span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果存在，直接返回失败</span></span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error_code&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key，表示已经解锁</span></span><br><span class="line">    redisTemplate.delete(locKey);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是简单的redis锁，如果在加锁和解锁中间，出现了异常，则redis里面会一直加上这把锁</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220302215144457.png/" alt="image-20220302215144457"></p>
<p>所以升级一下，让我们的代码更健壮，使用try catch finally  保证一定会释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String locKey = <span class="string">&quot;lockey&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果存在则true,成功则新增返回false</span></span><br><span class="line">    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, <span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果存在，直接返回失败</span></span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 删除key，表示已经解锁</span></span><br><span class="line">        redisTemplate.delete(locKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在这个时候，redis宕机了，依然会出现一直锁死的情况</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220302215511149.png/" alt="image-20220302215511149"></p>
<p>这个时候我们可以给锁设置一个超时时间，这样可以保证锁自动释放，不会一直锁死</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String locKey = <span class="string">&quot;lockey&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果存在则true,成功则新增返回false</span></span><br><span class="line">    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, <span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置超时时间，防止锁一直不释放</span></span><br><span class="line">    redisTemplate.expire(locKey,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 如果存在，直接返回失败</span></span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除key，表示已经解锁</span></span><br><span class="line">        redisTemplate.delete(locKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码看起来没有问题，但是实际会存在原子性问题</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220302220141345.png/" alt="image-20220302220141345"></p>
<p>这时候我们可以把</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().setIfAbsent(locKey, <span class="string">&quot;lock&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().setIfAbsent(locKey, <span class="string">&quot;lock&quot;</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String locKey = <span class="string">&quot;lockey&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果存在则true,成功则新增返回false,设置超时时间，防止锁一直不释放</span></span><br><span class="line">    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, <span class="string">&quot;lock&quot;</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 如果存在，直接返回失败</span></span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除key，表示已经解锁</span></span><br><span class="line">        redisTemplate.delete(locKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在高并发场景会存在问题</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220302221610591.png/" alt="image-20220302221610591"></p>
<p>如果存在上面这种情况，则永远加不上锁，前面的用户，会一直释放后面用户的锁，会存在超卖的问题</p>
<p>这时我们就需要用到uuid来进行加锁<code>解铃还须系铃人</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String locKey = <span class="string">&quot;lockey&quot;</span>;</span><br><span class="line">    <span class="comment">// 增加uuid防止被其他用户释放锁</span></span><br><span class="line">    String clientId = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 如果存在则true,成功则新增返回false,设置超时时间，防止锁一直不释放</span></span><br><span class="line">    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, clientId,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 如果存在，直接返回失败</span></span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果uuid相同则释放锁</span></span><br><span class="line">        <span class="keyword">if</span>(clientId.equals(redisTemplate.opsForValue().get(locKey)))&#123;</span><br><span class="line">            <span class="comment">// 删除key，表示已经解锁</span></span><br><span class="line">            redisTemplate.delete(locKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码解决了锁被其他人释放的问题，但是还是会存在一些问题</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220302224427117.png/" alt="image-20220302224427117"></p>
<p>很多人想的是对于超时时间，可以设置长一点，但是这种情况治标不治本，还是会有可能出现</p>
<p>以上这种情况需要用到<code>锁续命</code>，后台开一个定时任务，每过一段时间检查锁的业务是否还在执行，如果没执行完，就重置锁的超时时间</p>
<p>市面上有很多大牛对于这种情况提供了 解决方案</p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>我们可以使用redisson来使用分布式锁，简化了我们加锁的步骤</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 单机模式</span></span><br><span class="line">    Config config = <span class="keyword">new</span>  Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (Redisson)Redisson.create(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String locKey = <span class="string">&quot;lockey&quot;</span>;</span><br><span class="line">    RLock lock = redisson.getLock(locKey);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>,realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减成功，剩余库存：&quot;</span> + realStock);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减失败，库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是通过lua脚本实现代码的原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/foam077/images/raw/master/img/1090617-20190618183025891-1248337684.jpg/" alt="img"></p>
<p>1.加锁机制：</p>
<p>线程去获取锁，获取成功：执行lua脚本，保存数据到redis数据库</p>
<p>线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</p>
<p>2.看门狗</p>
<p>在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(不设置默认30秒），这样的目的主要是防止死锁的发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//设置锁1秒过去</span></span><br><span class="line">redissonLock.lock(<span class="string">&quot;redisson&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 业务逻辑需要咨询2秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">redissonLock.release(<span class="string">&quot;redisson&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程1 进来获得锁后，线程一切正常并没有宕机，但它的业务逻辑需要执行2秒，这就会有个问题，在 线程1 执行1秒后，这个锁就自动过期了</span></span><br><span class="line"><span class="comment">* 那么这个时候 线程2 进来了。那么就存在 线程1和线程2 同时在这段业务逻辑里执行代码，这当然是不合理的。</span></span><br><span class="line"><span class="comment">* 而且如果是这种情况，那么在解锁时系统会抛异常，因为解锁和加锁已经不是同一线程了，具体后面代码演示。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>所以这个时候<code>看门狗</code>就出现了，它的作用就是 线程1 业务还没有执行完，时间就过了，线程1 还想持有锁的话，就会启动一个watch dog后台线程，不断的延长锁key的生存时间。</p>
<p><code>注意</code> 正常这个看门狗线程是不启动的，还有就是这个看门狗启动后对整体性能也会有一定影响，所以不建议开启看门狗。</p>
<p>3.为啥使用lua脚本</p>
<p>如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p>
<p>4.分布式锁的缺陷</p>
<p>Redis分布式锁会有个缺陷，就是在Redis哨兵模式下:</p>
<p><code>客户端1</code> 对某个<code>master节点</code>写入了redisson锁，此时会异步复制给对应的 slave节点。但是这个过程中一旦发生 master节点宕机，主备切换，slave节点从变为了 master节点。</p>
<p>这时<code>客户端2</code> 来尝试加锁的时候，在新的master节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。</p>
<p>这时系统在业务语义上一定会出现问题，<strong>导致各种脏数据的产生</strong>。</p>
<p><code>缺陷</code>在哨兵模式或者主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库中间件</title>
    <url>/2022/04/17/0.0.9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h1><p>Cobar：阿里团队开发，已经多年没有维护更新</p>
<p>MyCat：基于Cobar二次开发，开源社区维护</p>
<p>OneProxy：不开源的商业中间件<code>专注性能和稳定性</code></p>
<p>KingShard：GO语言开发，在不断完善</p>
<p>Vitess：youtobe生产在使用，不支持MySql原生协议</p>
<p>Atlas：360团队基于MySqlProxy改写，高并发下不稳定</p>
<p>MaxScale：MaxScale是mariadb研发的中间件</p>
<p>MysqlRoute：MySql官方Oracle公司发布的中间件</p>
<p>ShardingJDBC：现在比较主流的中间件</p>
<p>SQL解析&gt;查询优化&gt;SQL路由&gt;SQL改写&gt;SQL执行&gt;结果归并</p>
]]></content>
      <tags>
        <tag>分库分表</tag>
        <tag>多数据源</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池工具类</title>
    <url>/2022/05/01/0.1.0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="1-编写线程池工具类"><a href="#1-编写线程池工具类" class="headerlink" title="1.编写线程池工具类"></a>1.编写线程池工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>,<span class="number">4</span>, <span class="number">10L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">100</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （1.8版本）使用线程池请求接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">executerPool</span><span class="params">(List&lt;T&gt; list)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = newFixedThreadPool();</span><br><span class="line">        List&lt;T&gt; collect = list.stream().filter(l -&gt; l <span class="keyword">instanceof</span> Runnable).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch count=<span class="keyword">new</span> CountDownLatch(collect.size());</span><br><span class="line">        <span class="keyword">for</span> (T runnable : collect) &#123;</span><br><span class="line">            Customers customers = (Customers) runnable;</span><br><span class="line">            customers.counts(count);</span><br><span class="line">            executorService.execute(customers);</span><br><span class="line">        &#125;</span><br><span class="line">        count.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （1.7版本）使用线程池请求接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">executerPool2</span><span class="params">(List&lt;T&gt; list)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = newFixedThreadPool();</span><br><span class="line">        List&lt;Customers&gt; runnables = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t <span class="keyword">instanceof</span> Customers)&#123;</span><br><span class="line">                runnables.add((Customers) t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch count=<span class="keyword">new</span> CountDownLatch(runnables.size());</span><br><span class="line">        <span class="keyword">for</span> (Customers runnable : runnables) &#123;</span><br><span class="line">            runnable.counts(count);</span><br><span class="line">            executorService.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        count.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-定义接口ThreadFactorys和Customers"><a href="#2-定义接口ThreadFactorys和Customers" class="headerlink" title="2.定义接口ThreadFactorys和Customers"></a>2.定义接口ThreadFactorys和Customers</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactorys</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">(CountDownLatch countDownLatch)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Customers</span> <span class="keyword">extends</span> <span class="title">Runnable</span>,<span class="title">ThreadFactorys</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-继承Customers"><a href="#3-继承Customers" class="headerlink" title="3.继承Customers"></a>3.继承Customers</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceRunnable</span> <span class="keyword">implements</span> <span class="title">Customers</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 线程计数器</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterfaceRunnable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        count.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-使用工具类进行调用（只需要把需要执行的类继承runnable方法，然后用list丢入工具类就行了）"><a href="#4-使用工具类进行调用（只需要把需要执行的类继承runnable方法，然后用list丢入工具类就行了）" class="headerlink" title="4.使用工具类进行调用（只需要把需要执行的类继承runnable方法，然后用list丢入工具类就行了）"></a>4.使用工具类进行调用（只需要把需要执行的类继承runnable方法，然后用list丢入工具类就行了）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;InterfaceRunnable&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> InterfaceRunnable(<span class="string">&quot;方法调用:&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadUtils.executerPool(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>工具类</tag>
        <tag>算法公式</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解</title>
    <url>/2022/04/22/0.1.1%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>注解是一种能被添加到java源代码中的元数据，方法、类、参数和包都可以用注解来修饰。注解可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理</p>
<h3 id="元注解介绍"><a href="#元注解介绍" class="headerlink" title="元注解介绍"></a>元注解介绍</h3><p>元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明</p>
<ul>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ul>
<p>对应的参数详情说明见末尾</p>
<p>修饰符：访问修饰符必须为public,不写默认为pubic</p>
<p>关键字：关键字为@interface</p>
<p>注解名称： 注解名称为自定义注解的名称</p>
<p>注解内容：注解中内容，对注解的描述</p>
<blockquote>
<p>以下内容采用枚举方式进行注解</p>
</blockquote>
<h3 id="1-定义枚举"><a href="#1-定义枚举" class="headerlink" title="1.定义枚举"></a>1.定义枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">newChannelEnum</span> </span>&#123;</span><br><span class="line">    BVC(<span class="string">&quot;BVC&quot;</span>,<span class="string">&quot;bvc_timeout&quot;</span>,<span class="string">&quot;BVC&quot;</span>,<span class="string">&quot;BVC_config&quot;</span>),</span><br><span class="line">    ACC(<span class="string">&quot;ACC&quot;</span>,<span class="string">&quot;acc_timeout&quot;</span>,<span class="string">&quot;ACC&quot;</span>,<span class="string">&quot;ACC_config&quot;</span>);</span><br><span class="line">    <span class="comment">// 渠道简称</span></span><br><span class="line">    <span class="keyword">private</span> String channel;</span><br><span class="line">    <span class="comment">// 超时时间配置</span></span><br><span class="line">    <span class="keyword">private</span> String timeout;</span><br><span class="line">    <span class="comment">// 全名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 接口详情配置</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line"></span><br><span class="line">    newChannelEnum(String channel, String timeout, String name, String interfaceName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInterfaceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(String timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2.定义注解"></a>2.定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD,ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InterfaceTagConfig &#123;</span><br><span class="line">    <span class="function">newChannelEnum <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-定义注解工具类"><a href="#3-定义注解工具类" class="headerlink" title="3.定义注解工具类"></a>3.定义注解工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTarHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 你需要使用注解的实体类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InterfaceDefault CLASS_LOAD_PATH = <span class="keyword">new</span> InterfaceDefault();</span><br><span class="line">    <span class="comment">// 存放标记了自定义注解方法的MAP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Method&gt; METHOD_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Method&gt;();</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有方法</span></span><br><span class="line">        Method[] methods = CLASS_LOAD_PATH.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 筛选打了注解的方法，并存入MAP</span></span><br><span class="line">            InterfaceTagConfig annotation = method.getAnnotation(InterfaceTagConfig.class);</span><br><span class="line">            <span class="keyword">if</span>(annotation != <span class="keyword">null</span>)&#123;</span><br><span class="line">                METHOD_MAP.put(String.valueOf(annotation.method()),method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InterfaceTarHelper <span class="title">getInstance</span><span class="params">(newChannelEnum methodEnum)</span></span>&#123;</span><br><span class="line">        InterfaceTarHelper helper = <span class="keyword">new</span> InterfaceTarHelper();</span><br><span class="line">        <span class="comment">// 根据枚举获取方法</span></span><br><span class="line">        helper.method = METHOD_MAP.get(String.valueOf(methodEnum));</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSearchFlightDetail</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 方法传参数</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(CLASS_LOAD_PATH, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用注解"><a href="#4-使用注解" class="headerlink" title="4.使用注解"></a>4.使用注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewSearch</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InterfaceTarget(method = InterfaceTagConfig.BVC)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BVCValidation</span><span class="params">(InterfaceParam param)</span></span>&#123;……&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InterfaceTarget(method = InterfaceTagConfig.ACC)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ACCValidation</span><span class="params">(InterfaceParam param)</span></span>&#123;……&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-调用方法"><a href="#5-调用方法" class="headerlink" title="5.调用方法"></a>5.调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData_new</span><span class="params">(String channel, InterfaceParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对应的枚举</span></span><br><span class="line">        newChannelEnum enums = newChannelEnum.getEnums(channel);</span><br><span class="line">        <span class="comment">// 调用对应的注解</span></span><br><span class="line">        InterfaceHelper.getInstance(enums).getSearchFlightDetail(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-附释"><a href="#6-附释" class="headerlink" title="6.附释"></a>6.附释</h3><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><strong>@Target</strong></h4><p><code>表明该注解可以应用的java元素类型</code></p>
<table>
<thead>
<tr>
<th>Target类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ElementType.TYPE</td>
<td>应用于类、接口（包括注解类型）、枚举</td>
</tr>
<tr>
<td>ElementType.FIELD</td>
<td>应用于属性（包括枚举中的常量）</td>
</tr>
<tr>
<td>ElementType.METHOD</td>
<td>应用于方法</td>
</tr>
<tr>
<td>ElementType.PARAMETER</td>
<td>应用于方法的形参</td>
</tr>
<tr>
<td>ElementType.CONSTRUCTOR</td>
<td>应用于构造函数</td>
</tr>
<tr>
<td>ElementType.LOCAL_VARIABLE</td>
<td>应用于局部变量</td>
</tr>
<tr>
<td>ElementType.ANNOTATION_TYPE</td>
<td>应用于注解类型</td>
</tr>
<tr>
<td>ElementType.PACKAGE</td>
<td>应用于包</td>
</tr>
<tr>
<td>ElementType.TYPE_PARAMETER</td>
<td>1.8版本新增，应用于类型变量</td>
</tr>
<tr>
<td>ElementType.TYPE_USE</td>
<td>1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）</td>
</tr>
</tbody></table>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><strong>@Retention</strong></h4><p><code>表明该注解的生命周期</code></p>
<table>
<thead>
<tr>
<th><strong>生命周期类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RetentionPolicy.SOURCE</td>
<td>编译时被丢弃，不包含在类文件中</td>
</tr>
<tr>
<td>RetentionPolicy.CLASS</td>
<td>JVM加载时被丢弃，包含在类文件中，默认值</td>
</tr>
<tr>
<td>RetentionPolicy.RUNTIME</td>
<td>由JVM 加载，包含在类文件中，在运行时可以被获取到</td>
</tr>
</tbody></table>
<h4 id="Document"><a href="#Document" class="headerlink" title="@Document"></a><strong>@Document</strong></h4><p><code>表明该注解标记的元素可以被Javadoc 或类似的工具文档化</code></p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><strong>@Inherited</strong></h4><p><code>表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解</code></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>自定义注解</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>ip地址白名单校验</title>
    <url>/2022/04/04/0.1.3ip%E5%9C%B0%E5%9D%80%E7%99%BD%E5%90%8D%E5%8D%95%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.service.taobao.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WhiteIPInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yinjuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022-01-12 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteIPInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IP的正则</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern pattern = Pattern</span><br><span class="line">            .compile(<span class="string">&quot;(1\\d&#123;1,2&#125;|2[0-4]\\d|25[0-5]|\\d&#123;1,2&#125;)\\.&quot;</span> + <span class="string">&quot;(1\\d&#123;1,2&#125;|2[0-4]\\d|25[0-5]|\\d&#123;1,2&#125;)\\.&quot;</span></span><br><span class="line">                    + <span class="string">&quot;(1\\d&#123;1,2&#125;|2[0-4]\\d|25[0-5]|\\d&#123;1,2&#125;)\\.&quot;</span> + <span class="string">&quot;(1\\d&#123;1,2&#125;|2[0-4]\\d|25[0-5]|\\d&#123;1,2&#125;)&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ALLOW_ALL_FLAG = <span class="string">&quot;*&quot;</span>;	<span class="comment">// 允许所有ip标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DENY_ALL_FLAG = <span class="string">&quot;0&quot;</span>; 	<span class="comment">// 禁止所有ip标志位</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 获取访问的ip地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String ip = request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equals(ip)) &#123;</span><br><span class="line">            ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据IP白名单设置获取可用的IP列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> allowIp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getAvaliIpList</span><span class="params">(String allowIp)</span> </span>&#123;</span><br><span class="line">        String[] splitRex = allowIp.split(<span class="string">&quot;;&quot;</span>);<span class="comment">// 拆分出白名单正则</span></span><br><span class="line">        Set&lt;String&gt; ipList = <span class="keyword">new</span> HashSet&lt;String&gt;(splitRex.length);</span><br><span class="line">        <span class="keyword">for</span> (String allow : splitRex) &#123;</span><br><span class="line">            allow = allow.trim();</span><br><span class="line">            <span class="keyword">if</span> (allow.contains(<span class="string">&quot;*&quot;</span>)) &#123;<span class="comment">// 处理通配符 *</span></span><br><span class="line">                String[] ips = allow.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                String[] from = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span> &#125;;</span><br><span class="line">                String[] end = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;255&quot;</span>, <span class="string">&quot;255&quot;</span>, <span class="string">&quot;255&quot;</span>, <span class="string">&quot;255&quot;</span> &#125;;</span><br><span class="line">                List&lt;String&gt; tem = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ips.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (ips[i].indexOf(<span class="string">&quot;*&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                        tem = complete(ips[i]);</span><br><span class="line">                        from[i] = <span class="keyword">null</span>;</span><br><span class="line">                        end[i] = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        from[i] = ips[i];</span><br><span class="line">                        end[i] = ips[i];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                StringBuilder fromIP = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                StringBuilder endIP = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                    <span class="keyword">if</span> (from[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        fromIP.append(from[i]).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                        endIP.append(end[i]).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fromIP.append(<span class="string">&quot;[*].&quot;</span>);</span><br><span class="line">                        endIP.append(<span class="string">&quot;[*].&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                fromIP.deleteCharAt(fromIP.length() - <span class="number">1</span>);</span><br><span class="line">                endIP.deleteCharAt(endIP.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String s : tem) &#123;</span><br><span class="line">                    String ip = fromIP.toString().replace(<span class="string">&quot;[*]&quot;</span>, s.split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]) + <span class="string">&quot;-&quot;</span></span><br><span class="line">                            + endIP.toString().replace(<span class="string">&quot;[*]&quot;</span>, s.split(<span class="string">&quot;;&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (validate(ip)) &#123;</span><br><span class="line">                        ipList.add(ip);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow.contains(<span class="string">&quot;/&quot;</span>)) &#123;<span class="comment">// 处理 网段 xxx.xxx.xxx./24</span></span><br><span class="line">                ipList.add(allow);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 处理单个 ip 或者 范围</span></span><br><span class="line">                <span class="keyword">if</span> (validate(allow)) &#123;</span><br><span class="line">                    ipList.add(allow);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ipList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 	对单个IP节点进行范围限定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回限定后的IP范围，格式为List[10;19, 100;199]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">complete</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; com = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = arg.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            com.add(<span class="string">&quot;0;255&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">            String s1 = complete(arg, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s1 != <span class="keyword">null</span>)</span><br><span class="line">                com.add(s1);</span><br><span class="line">            String s2 = complete(arg, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (s2 != <span class="keyword">null</span>)</span><br><span class="line">                com.add(s2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String s1 = complete(arg, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s1 != <span class="keyword">null</span>)</span><br><span class="line">                com.add(s1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">complete</span><span class="params">(String arg, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String from = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String end = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            from = arg.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            end = arg.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;9&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            from = arg.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;00&quot;</span>);</span><br><span class="line">            end = arg.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;99&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Integer.valueOf(from) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Integer.valueOf(end) &gt; <span class="number">255</span>)</span><br><span class="line">            end = <span class="string">&quot;255&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> from + <span class="string">&quot;;&quot;</span> + end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	 在添加至白名单时进行格式校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        String[] temp = ip.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : temp)</span><br><span class="line">            <span class="keyword">if</span> (!pattern.matcher(s).matches()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 	根据IP,及可用Ip列表来判断ip是否包含在白名单之中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPermited</span><span class="params">(String ip, Set&lt;String&gt; ipList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ipList.isEmpty() || ipList.contains(ip))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (String allow : ipList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allow.indexOf(<span class="string">&quot;-&quot;</span>) &gt; -<span class="number">1</span>) &#123;<span class="comment">// 处理 类似 192.168.0.0-192.168.2.1</span></span><br><span class="line">                String[] tempAllow = allow.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                String[] from = tempAllow[<span class="number">0</span>].split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                String[] end = tempAllow[<span class="number">1</span>].split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                String[] tag = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                <span class="keyword">boolean</span> check = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">// 对IP从左到右进行逐段匹配</span></span><br><span class="line">                    <span class="keyword">int</span> s = Integer.valueOf(from[i]);</span><br><span class="line">                    <span class="keyword">int</span> t = Integer.valueOf(tag[i]);</span><br><span class="line">                    <span class="keyword">int</span> e = Integer.valueOf(end[i]);</span><br><span class="line">                    <span class="keyword">if</span> (!(s &lt;= t &amp;&amp; t &lt;= e)) &#123;</span><br><span class="line">                        check = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (check)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow.contains(<span class="string">&quot;/&quot;</span>)) &#123;<span class="comment">// 处理 网段 xxx.xxx.xxx./24</span></span><br><span class="line">                <span class="keyword">int</span> splitIndex = allow.indexOf(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                <span class="comment">// 取出子网段</span></span><br><span class="line">                String ipSegment = allow.substring(<span class="number">0</span>, splitIndex); <span class="comment">// 192.168.3.0</span></span><br><span class="line">                <span class="comment">// 子网数</span></span><br><span class="line">                String netmask = allow.substring(splitIndex + <span class="number">1</span>);<span class="comment">// 24</span></span><br><span class="line">                <span class="comment">// ip 转二进制</span></span><br><span class="line">                <span class="keyword">long</span> ipLong = ipToLong(ip);</span><br><span class="line">                <span class="comment">//子网二进制</span></span><br><span class="line">                <span class="keyword">long</span> maskLong=(<span class="number">2L</span>&lt;&lt;<span class="number">32</span> -<span class="number">1</span>) -(<span class="number">2L</span> &lt;&lt; Integer.valueOf(<span class="number">32</span>-Integer.valueOf(netmask))-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// ip与和子网相与 得到 网络地址</span></span><br><span class="line">                String calcSegment = longToIP(ipLong &amp; maskLong);</span><br><span class="line">                <span class="comment">// 如果计算得出网络地址和库中网络地址相同 则合法</span></span><br><span class="line">                <span class="keyword">if</span>(ipSegment.equals(calcSegment))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 	根据IP地址，及IP白名单设置规则判断IP是否包含在白名单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipWhiteConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPermitedByRequest</span><span class="params">(HttpServletRequest request, String ipWhiteConfig)</span> </span>&#123;</span><br><span class="line">        String ip = getIpAddr(request);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == ip || <span class="string">&quot;&quot;</span>.equals(ip) || <span class="keyword">null</span> == ipWhiteConfig)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//ip格式不对</span></span><br><span class="line">        <span class="keyword">if</span>(!pattern.matcher(ip).matches()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_ALLOW_ALL_FLAG.equals(ipWhiteConfig))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_DENY_ALL_FLAG.equals(ipWhiteConfig))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;String&gt; ipList = getAvaliIpList(ipWhiteConfig.replaceAll(<span class="string">&quot;；&quot;</span>, <span class="string">&quot;;&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> isPermited(ip, ipList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 	根据IP地址，及IP白名单设置规则判断IP是否包含在白名单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ipWhiteConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPermited</span><span class="params">(String ip, String ipWhiteConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == ip || <span class="string">&quot;&quot;</span>.equals(ip) || <span class="keyword">null</span> == ipWhiteConfig)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//ip格式不对</span></span><br><span class="line">        <span class="keyword">if</span>(!pattern.matcher(ip).matches()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_ALLOW_ALL_FLAG.equals(ipWhiteConfig))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_DENY_ALL_FLAG.equals(ipWhiteConfig))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;String&gt; ipList = getAvaliIpList(ipWhiteConfig.replaceAll(<span class="string">&quot;；&quot;</span>, <span class="string">&quot;;&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> isPermited(ip, ipList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">ipToLong</span><span class="params">(String strIP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] ip = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 先找到IP地址字符串中.的位置</span></span><br><span class="line">        <span class="keyword">int</span> position1 = strIP.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> position2 = strIP.indexOf(<span class="string">&quot;.&quot;</span>, position1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> position3 = strIP.indexOf(<span class="string">&quot;.&quot;</span>, position2 + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将每个.之间的字符串转换成整型</span></span><br><span class="line">        ip[<span class="number">0</span>] = Long.parseLong(strIP.substring(<span class="number">0</span>, position1));</span><br><span class="line">        ip[<span class="number">1</span>] = Long.parseLong(strIP.substring(position1 + <span class="number">1</span>, position2));</span><br><span class="line">        ip[<span class="number">2</span>] = Long.parseLong(strIP.substring(position2 + <span class="number">1</span>, position3));</span><br><span class="line">        ip[<span class="number">3</span>] = Long.parseLong(strIP.substring(position3 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> (ip[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) + (ip[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) + (ip[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) + ip[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将10进制整数形式转换成127.0.0.1形式的IP地址</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">longToIP</span><span class="params">(<span class="keyword">long</span> longIP)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 直接右移24位</span></span><br><span class="line">        sb.append(String.valueOf(longIP &gt;&gt;&gt; <span class="number">24</span>));</span><br><span class="line">        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">// 将高8位置0，然后右移16位</span></span><br><span class="line">        sb.append(String.valueOf((longIP &amp; <span class="number">0x00FFFFFF</span>) &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        sb.append(String.valueOf((longIP &amp; <span class="number">0x0000FFFF</span>) &gt;&gt;&gt; <span class="number">8</span>));</span><br><span class="line">        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        sb.append(String.valueOf(longIP &amp; <span class="number">0x000000FF</span>));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ipWhilte = <span class="string">&quot;1.168.1.1;&quot;</span> <span class="comment">//设置单个IP的白名单 //</span></span><br><span class="line">                + <span class="string">&quot;192.*； &quot;</span> <span class="comment">//设置ip通配符,对一个ip段进行匹配</span></span><br><span class="line">                + <span class="string">&quot;192.168.1.1-192.168.1.3； &quot;</span> <span class="comment">//设置一个IP范围</span></span><br><span class="line">                + <span class="string">&quot;25.168.4.0/24 &quot;</span>; <span class="comment">//設置一个网段</span></span><br><span class="line">        System.out.println(WhiteIPInterceptor.isPermited(<span class="string">&quot;192.168.1.1&quot;</span>,ipWhilte));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>ip</tag>
        <tag>白名单</tag>
        <tag>校验</tag>
      </tags>
  </entry>
  <entry>
    <title>java文件用GZip压缩gz</title>
    <url>/2022/04/04/0.1.4java%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>描述：利用Gzip进行文件压缩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.GZIPInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.GZIPOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZipUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXT = <span class="string">&quot;.gz&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String userHome = System.getProperties().getProperty(<span class="string">&quot;user.home&quot;</span>); <span class="comment">// 用户目录，如：C:\Users\chushiyun</span></span><br><span class="line">       String fileName = userHome+<span class="string">&quot;/01.jpg&quot;</span>; <span class="comment">// 用户目录下的01.jpg 会被压缩成01.jpg.gz</span></span><br><span class="line">       compress(<span class="keyword">new</span> File(fileName));</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compress(<span class="keyword">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(data);</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 压缩</span></span><br><span class="line">        compress(bais, baos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] output = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        baos.flush();</span><br><span class="line">        baos.close();</span><br><span class="line"></span><br><span class="line">        bais.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        compress(file, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delete</span></span><br><span class="line"><span class="comment">     *            是否删除原始文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(File file, <span class="keyword">boolean</span> delete)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file.getPath() + EXT);</span><br><span class="line"></span><br><span class="line">        compress(fis, fos);</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delete) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(InputStream is, OutputStream os)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        GZIPOutputStream gos = <span class="keyword">new</span> GZIPOutputStream(os);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER];</span><br><span class="line">        <span class="keyword">while</span> ((count = is.read(data, <span class="number">0</span>, BUFFER)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            gos.write(data, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gos.finish();</span><br><span class="line"></span><br><span class="line">        gos.flush();</span><br><span class="line">        gos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        compress(path, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delete</span></span><br><span class="line"><span class="comment">     *            是否删除原始文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(String path, <span class="keyword">boolean</span> delete)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        compress(file, delete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据解压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decompress(<span class="keyword">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(data);</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解压缩</span></span><br><span class="line"></span><br><span class="line">        decompress(bais, baos);</span><br><span class="line"></span><br><span class="line">        data = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        baos.flush();</span><br><span class="line">        baos.close();</span><br><span class="line"></span><br><span class="line">        bais.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件解压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        decompress(file, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件解压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delete</span></span><br><span class="line"><span class="comment">     *            是否删除原始文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(File file, <span class="keyword">boolean</span> delete)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file.getPath().replace(EXT,</span><br><span class="line">                <span class="string">&quot;&quot;</span>));</span><br><span class="line">        decompress(fis, fos);</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delete) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据解压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(InputStream is, OutputStream os)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        GZIPInputStream gis = <span class="keyword">new</span> GZIPInputStream(is);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER];</span><br><span class="line">        <span class="keyword">while</span> ((count = gis.read(data, <span class="number">0</span>, BUFFER)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(data, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件解压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        decompress(path, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件解压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delete</span></span><br><span class="line"><span class="comment">     *            是否删除原始文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(String path, <span class="keyword">boolean</span> delete)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        decompress(file, delete);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>gzip</tag>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql创建定时任务</title>
    <url>/2022/04/23/0.1.6mysql%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>需求：定时删除三个月之前的数据</p>
</blockquote>
<p>1.编写需要执行的sql语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 因为表数据过大（大约2亿数据），需要先查询三个月之前的id节点，增加查询速度</span><br><span class="line">select MAX(id) from other_log_info where DATE_FORMAT(createtime,&#x27;%Y-%m-%d&#x27;) = DATE_SUB(CURDATE(),INTERVAL 3 MONTH);</span><br><span class="line"></span><br><span class="line">## 查询的sql一次不能删除太多数据，防止锁表</span><br><span class="line">select * from other_log_info where id &lt; (select MAX(id) from other_log_info where DATE_FORMAT(createtime,&#x27;%Y-%m-%d&#x27;) = DATE_SUB(CURDATE(),INTERVAL 3 MONTH)) LIMIT 0,1000</span><br><span class="line"></span><br><span class="line">## 由于delete不能直接删除子查询表中的数据，必须用过嵌套一层的方式来解决</span><br><span class="line">## 第二种执行方式，如果对于sql比较熟悉，可以用存储过程的&quot;游标&quot;进行循环</span><br><span class="line">DELETE FROM other_log_info where id in </span><br><span class="line">	(select t2.id from </span><br><span class="line">		(select id from other_log_info where </span><br><span class="line">			id &lt; (select MAX(id) from other_log_info where createtime &lt; DATE_SUB(CURDATE(),INTERVAL 3 MONTH)) LIMIT 0,1000) t2)</span><br></pre></td></tr></table></figure>

<p>游标使用方式：<a href="https://www.cnblogs.com/cbt-home/p/15269736.html">https://www.cnblogs.com/cbt-home/p/15269736.html</a></p>
<ul>
<li>CURDATE() 返回当前日期</li>
<li>CURNOW() 返回当前datetime</li>
<li>INTERVAL 是mysql间隔值，用法为INTERVAL expr unit。INTERVAL 3 DAY表示三天的间隔</li>
<li>DATE_SUB(start_date,INTERVAL expr unit);</li>
</ul>
<p>2.编写存储过程</p>
<p>存储过程相当于mysql的函数，它是存储在数据库服务器中的一组sql语句，通过调用这个函数的名称来执行这些sql语句命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 分隔符切换防止“;”直接分隔了</span><br><span class="line">DELIMITER //</span><br><span class="line">-- 创建存储过程</span><br><span class="line">CREATE procedure del_log2()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT * FROM xxl_job_log WHERE trigger_time &lt; DATE_SUB(CURDATE(),INTERVAL 5 MONTH);</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DELIMITER是分割符的意思，声明存储过程前将&quot;//&quot;声明为分隔符，这样存储过程中的“;”才不会被当作分隔符处理。声明结束后再还原分隔符。</code></li>
<li>存储过程也可以带参数，存储过程名(参数)</li>
<li>在声明存储过程前要先用use database_name切换到想要应用的数据库，否则存储过程会应用到默认数据库中</li>
</ul>
<p>查看存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- db指的数据库名</span><br><span class="line">select * from mysql.proc where db = &quot;xxl_job&quot;</span><br></pre></td></tr></table></figure>

<p>调用存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call del_log();</span><br></pre></td></tr></table></figure>

<p>3.编写事件调度器（定时任务）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 确认是否开启事件调度器</span><br><span class="line">SHOW VARIABLES LIKE &#x27;event_scheduler&#x27;;</span><br><span class="line"></span><br><span class="line">-- 开启事件调度器</span><br><span class="line">SET GLOBAL event_scheduler = ON;</span><br></pre></td></tr></table></figure>

<p>创建事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建调度任务(从2022-4-22开始，每天执行一次del_data())</span><br><span class="line">create event del_event  </span><br><span class="line">on schedule </span><br><span class="line">EVERY 1 day  </span><br><span class="line">STARTS &#x27;2022-4-22 00:00:00&#x27; </span><br><span class="line">do call del_data()</span><br></pre></td></tr></table></figure>

<p>查看事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看事件</span><br><span class="line">SHOW EVENTS;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/foam077/images/raw/master/img/123.jpg/" alt="image-20220422104326667"></p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/34.jpg/" alt="image-20220422104354508"></p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/PZ_%7D(YABF6HUB3~ULXWF5R3.png/" alt="image-20220422104419241"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>redis存储Data truncation: Incorrect datetime value</title>
    <url>/2022/03/07/0.1.7redis%E5%AD%98%E5%82%A8Data-truncation-Incorrect-datetime-value/</url>
    <content><![CDATA[<p>最近在编写项目时，用redis存储结果一直报转换异常<br><img src="https://gitee.com/foam077/images/raw/master/img/f0a78853cfed40ad8b8a8b35800a7f52.png/" alt="在这里插入图片描述"><br>对此我有了以下思路<br>1.在mysql进行格式转换<br>2.在java先转换<br>3.存json之前就进行格式转换</p>
<p>但是以上方法都不行，因为数据需要的是date类型，如果走转换又过慢<br><img src="https://gitee.com/foam077/images/raw/master/img/374ed7336a77406f90aa8dc2ea8b4530.png/" alt="在这里插入图片描述"><br>有大佬提了一下使用序列化解决，我就尝试了一下，还真可以,以下是我编写思路<br>1.首先需要序列化的类继承Serializable接口<br><img src="https://gitee.com/foam077/images/raw/master/img/aeb43a6c0aef4058802e25afc80b6253.png/" alt="在这里插入图片描述"><br>2.编写序列化工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tiantai.policy.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object object) &#123;</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(object);</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;序列化失败&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;反序列化失败&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用序列化存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer , Object&gt; objectObjectHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                                objectObjectHashMap.put(airChannelEnum.getType(), SerializeUtil.serialize(selectPage));</span><br><span class="line">                                redisTemplate.opsForList().leftPush(<span class="string">&quot;error&quot;</span>,gson.toJson(objectObjectHashMap));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/foam077/images/raw/master/img/cb7066c9f316480a85b9e0864992880e.png/" alt="在这里插入图片描述"><br>4.反序列化读取<br><img src="https://gitee.com/foam077/images/raw/master/img/a2bbe2c6ba594e29a77afa1c7016881b.png/" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page deserialize = (Page)SerializeUtil.deserialize(entry.getValue());</span><br></pre></td></tr></table></figure>
<p>第一个红框是我用gson进行json转换<br>第二个红框是序列化后强转为原对象</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>redis锁</title>
    <url>/2022/02/23/0.1.8redis%E9%94%81/</url>
    <content><![CDATA[<p>暂时没时间整细节，给个粗略的记录一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.util.qunar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.service.qunar.FQunarSearchService;</span><br><span class="line"><span class="keyword">import</span> com.service.zl.ValidationCabinAndPrice_QNR;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_TITLE = <span class="string">&quot;QNRLock_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOutSecond</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">acquireSecond</span><span class="params">(String lockName, Integer waitTime, Integer timeOutSecond)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String key = LOCK_TITLE + lockName;</span><br><span class="line">            RLock mylock = redisLock().getLock(key);</span><br><span class="line">            <span class="comment">//lock提供带timeout参数，timeout结束强制解锁，防止死锁</span></span><br><span class="line">            <span class="comment">//先尝试在超时时间内获取锁，如果没有获取到，此时如果等待时间还有剩余进入循环不断取尝试获取锁 直到时间结束退出  循环中是订阅，时间结束取消订阅</span></span><br><span class="line">            <span class="keyword">return</span> mylock.tryLock(waitTime, timeOutSecond, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient <span class="title">redisLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(redissonClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FQunarSearchService.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(redissonClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">                    config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">                            .setPassword(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">                            .setDatabase(<span class="number">17</span>);</span><br><span class="line">                    redissonClient = Redisson.create(config);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(String lockName)</span></span>&#123;</span><br><span class="line">        String key = LOCK_TITLE + lockName;</span><br><span class="line">        RLock mylock = redissonClient.getLock(key);</span><br><span class="line">        mylock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisTemplate统一集成</title>
    <url>/2022/05/06/0.2.1RedisTemplate%E7%BB%9F%E4%B8%80%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h2 id="1-配置redis-config"><a href="#1-配置redis-config" class="headerlink" title="1.配置redis-config"></a>1.配置redis-config</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jedis 连接池配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.maxIdle&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numTestsPerEvictionRun&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stringRedisSerializer&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdkRedisSerializer&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisConnectionZero&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redisst.hostName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redisst.port&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redisst.timeout&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usePool&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redisst.usePool&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redisst.password&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redisst.db0&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplateZero&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisConnectionZero&quot;</span> /&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stringRedisSerializer&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashKeySerializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdkRedisSerializer&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueSerializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdkRedisSerializer&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-定义枚举"><a href="#2-定义枚举" class="headerlink" title="2.定义枚举"></a>2.定义枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CommonRedisEnums</span> </span>&#123;</span><br><span class="line">    O_DB_0(<span class="string">&quot;redisTemplateZero&quot;</span>,<span class="string">&quot;ODB0&quot;</span>);</span><br><span class="line">    <span class="comment">// 对应redis-config中的bean名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 别名</span></span><br><span class="line">    <span class="keyword">private</span> String asName;</span><br><span class="line"></span><br><span class="line">    CommonRedisEnums(String name, String asName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.asName = asName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAsName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用SpringAppContextHolder获取bean"><a href="#3-使用SpringAppContextHolder获取bean" class="headerlink" title="3.使用SpringAppContextHolder获取bean"></a>3.使用SpringAppContextHolder获取bean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,RedisTemplate&gt; redisTemplateMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getRedis</span><span class="params">(CommonRedisEnums enums)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!redisTemplateMap.containsKey(enums.getName()))&#123;</span><br><span class="line">      RedisTemplate redisBean = (RedisTemplate) SpringAppContextHolder</span><br><span class="line">            .getBean(enums.getName());</span><br><span class="line">      <span class="keyword">if</span>(redisBean != <span class="keyword">null</span>)&#123;</span><br><span class="line">         redisTemplateMap.put(enums.getName(),redisBean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-使用工具类进行调用"><a href="#4-使用工具类进行调用" class="headerlink" title="4.使用工具类进行调用"></a>4.使用工具类进行调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">searchKeys</span><span class="params">(List&lt;String&gt; keys,CommonRedisEnums enums)</span></span>&#123;</span><br><span class="line">   getRedis(enums);</span><br><span class="line">   <span class="keyword">return</span> batchQueryByKeys(keys, <span class="keyword">false</span>,redisTemplateMap.get(enums.getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">batchQueryByKeys</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; keys, Boolean useParallel, <span class="keyword">final</span> RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == keys || keys.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == useParallel) &#123;</span><br><span class="line">      useParallel = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Object object = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">         connection.openPipeline();</span><br><span class="line">         <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bkey = redisTemplate.getStringSerializer().serialize(key);</span><br><span class="line">            redisTemplate.getStringSerializer().serialize(JSON.toJSONString(connection.get(bkey)));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> connection.closePipeline();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   List&lt;Object&gt; results = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == object) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      results = (List) object;</span><br><span class="line">   &#125;</span><br><span class="line">   Map&lt;String, Object&gt; resultMap = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (useParallel) &#123;</span><br><span class="line">      Map&lt;String, Object&gt; resultMapOne = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Object&gt;());</span><br><span class="line">      <span class="keyword">for</span> (String t : keys) &#123;</span><br><span class="line">         resultMapOne.put(t, results.get(keys.indexOf(t)));</span><br><span class="line">      &#125;</span><br><span class="line">      resultMap = resultMapOne;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Map&lt;String, Object&gt; resultMapTwo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (String t : keys) &#123;</span><br><span class="line">         Object o = results.get(keys.indexOf(t));</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != o) &#123;</span><br><span class="line">            String val = (String) redisTemplate.getStringSerializer().deserialize((<span class="keyword">byte</span>[]) o);</span><br><span class="line">            resultMapTwo.put(t, val);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      resultMap = resultMapTwo;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用@Autowired的时候，对于static标识的变量或者方法一般是获取到的null值常规的方法已经使用不了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> NewRedisZeroService redisZeroService;</span><br></pre></td></tr></table></figure>

<p>需要使用注入方法的形式来使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ZXSearchNewService_new zxSearchNewService_new;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> QueueProducerService messageService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">zxSearch</span><span class="params">(QueueProducerService queueProducerService,ZXSearchNewService_new zxSearchNewService_new)</span> </span>&#123;</span><br><span class="line">    zxSearch.zxSearchNewService_new = zxSearchNewService_new;</span><br><span class="line">    zxSearch.messageService = queueProducerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在工具类中使用了，不需要通过传参的形式去获取</p>
]]></content>
      <tags>
        <tag>工具类</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA内存调优</title>
    <url>/2022/05/06/0.2.0IDEA%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/c18092694487t/article/details/116915386?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=1">idea2020无法启动报错初始堆值大于最大堆值_寒烟雾柳的博客-CSDN博客</a></p>
<p>调整内存的时候一定Xms2048m不能大于Xmx4096m【否则idea启动不起来】</p>
<p>xmx建议设置为（总内存的3/4 ÷ 你要开的idea个数），这样才不会卡</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-Xms1024m</span><br><span class="line">-Xmx8192m</span><br><span class="line">-XX:MaxPermSize=2048m</span><br><span class="line">-XX:ReservedCodeCacheSize=256m</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Dsun.awt.keepWorkingSetOnMinimize=true</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">#-Djsse.enableSNIExtension=false</span><br><span class="line">-XX:+UseCodeCacheFlushing</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>ShardingJDBC简单介绍</title>
    <url>/2022/04/10/0.1.9ShardingJDBC%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="ShardingJDBC"><a href="#ShardingJDBC" class="headerlink" title="ShardingJDBC"></a>ShardingJDBC</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>ShardingJDBC是当当网研发的开源分布式数据库中间件，从 3.0 开始Sharding-JDBC被包含在 Sharding-Sphere中，之后该项目进入进入Apache孵化器，4.0版本之后的版本为Apache版本。</p>
</blockquote>
<p><strong>ShardingSphere</strong>是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p>
<p>官方地址：<a href="https://shardingsphere.apache.org/document/current/cn/overview/">https://shardingsphere.apache.org/document/current/cn/overview/</a></p>
<p>它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，<code>完全兼容JDBC和各种ORM框架</code></p>
<p>在 maven 的工程里面，我们使用它的方式是<strong>引入依赖</strong>，然后<strong>进行配置</strong>就可以了，不用像 <strong>Mycat 一样独立运行一个服务</strong>，<strong>客户端不需要修改任何一行代码</strong>，原来是 SSM 连接数据库，还是 SSM，因为它是支持 MyBatis 的</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Sharding-JDBC的核心功能为<strong>数据分片</strong>和<strong>读写分离</strong>，通过Sharding-JDBC，应用可以<strong>透明</strong>的使用jdbc访问已经分库分表、读写分离的多个数据源，而不用关心数据源的数量以及数据如何分布。 </p>
<ul>
<li>适用于任何基于Java的ORM框架，如：Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC</li>
<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等</li>
<li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL</li>
</ul>
<p>分库分表的一些<strong>核心动作</strong>，比如 <strong>SQL 解析，路由，执行，结果处理</strong>，都是由它来完成的</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/IY%7B9E$35GLDFQ5]7VJZI(%7BA.png/" alt="img"></p>
<p>上图展示了Sharding-Jdbc的工作方式，使用Sharding-Jdbc前需要人工对数据库进行分库分表</p>
<p>在应用程序中加入Sharding-Jdbc的Jar包，应用程序通过Sharding-Jdbc操作分库分表后的数据库和数据表，由于Sharding-Jdbc是对Jdbc驱动的增强，使用Sharding-Jdbc就像使用Jdbc驱动一样，在应用程序中是无需指定具体要操作的分库和分表的</p>
<p>主要概念：<strong>逻辑表会在 SQL 解析和路由时被替换成真实的表名</strong></p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/B0X]87($BB5AMRQ%VL3BI6L.png/" alt="img"></p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>以下为网上统计数据</p>
<p>1.性能损耗测试：服务器资源充足、并发数相同，比较JDBC和Sharding-JDBC性能损耗，Sharding-JDBC相对JDBC损耗不超过7%</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220410220914283.png/" alt="image-20220410220914283"></p>
<p>2.性能对比测试：服务器资源使用到极限，相同的场景JDBC与Sharding-JDBC的吞吐量相当</p>
<p>3.性能对比测试：服务器资源使用到极限，Sharding-JDBC采用分库分表后，Sharding-JDBC吞吐量较JDBC不分表有接近2倍的提升。 </p>
<p><img src="https://img-blog.csdnimg.cn/556f9c997706494b8b72c118c3d882cd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pe25YWJXzEwMjQ=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="ShardingJDBC引入"><a href="#ShardingJDBC引入" class="headerlink" title="ShardingJDBC引入"></a>ShardingJDBC引入</h2><p>1.引入boot的依赖整合包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding‐jdbc‐spring‐boot‐starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0‐RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.创建数据库和表</p>
<ul>
<li><p>创建订单库order_db </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `order_db` <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8_general_ci&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在order_db中创建t_order_1、t_order_2表 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_order_1`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order_1`(</span><br><span class="line">    `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单id&#x27;</span>,</span><br><span class="line">    `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单价格&#x27;</span>,</span><br><span class="line">    `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单用户id&#x27;</span>,</span><br><span class="line">    `status` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_order_2`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order_2` (</span><br><span class="line">    `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单id&#x27;</span>,</span><br><span class="line">    `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单价格&#x27;</span>,</span><br><span class="line">    `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单用户id&#x27;</span>,</span><br><span class="line">    `status` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.application.properties配置规则</p>
<ul>
<li><p>定义数据源</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义数据源m1，并对m1进行实际的参数配置</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span>=<span class="string">m1</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSoure</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.driver‐class‐name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.url</span>=<span class="string">jdbc:mysql://localhost:3306/order_db?useUnicode=true</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.m1.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置数据节点</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定t_order表的数据分布情况，配置数据节点</span></span><br><span class="line"><span class="comment"># 他分布在m1.t_order_1，m1.t_order_2</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.actual‐data‐nodes</span>=<span class="string">m1.t_order_$‐&gt;&#123;1..2&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置主键策略</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定t_order表的主键生成策略为SNOWFLAKE,SNOWFLAKE是一种分布式自增算法，保证id全局唯一</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key‐generator.column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key‐generator.type</span>=<span class="string">SNOWFLAKE</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置分片算法</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定t_order表的分片策略，分片策略包括分片键和分片算法</span></span><br><span class="line"><span class="comment"># order_id为偶数的数据落在t_order_1，为奇数的落在t_order_2，分表策略的表达式为 t_order_$-&gt;&#123;order_id % 2 + 1&#125;</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table‐strategy.inline.sharding‐column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table‐strategy.inline.algorithm‐expression</span>=<span class="string">t_order_$‐&gt;&#123;order_id % 2 + 1&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>日志输出sql</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.shardingsphere.props.sql.show</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.数据操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*** 新增订单 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> price 订单价格 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userId 用户id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> status 订单状态 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into t_order(price,user_id,status) value(#&#123;price&#125;,#&#123;userId&#125;,#&#123;status&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOrder</span><span class="params">(<span class="meta">@Param(&quot;price&quot;)</span> BigDecimal price, <span class="meta">@Param(&quot;userId&quot;)</span>Long userId, <span class="meta">@Param(&quot;status&quot;)</span>String status)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 根据id列表查询多个订单</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> orderIds 订单id列表 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Select(&#123;&quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">        &quot;select &quot; +</span></span><br><span class="line"><span class="meta">        &quot; * &quot; +</span></span><br><span class="line"><span class="meta">        &quot; from t_order t&quot; +</span></span><br><span class="line"><span class="meta">        &quot; where t.order_id in &quot; +</span></span><br><span class="line"><span class="meta">        &quot;&lt;foreach collection=&#x27;orderIds&#x27; item=&#x27;id&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">        &quot; #&#123;id&#125; &quot; +</span></span><br><span class="line"><span class="meta">        &quot;&lt;/foreach&gt;&quot;+</span></span><br><span class="line"><span class="meta">        &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line">    <span class="function">List&lt;Map&gt; <span class="title">selectOrderbyIds</span><span class="params">(<span class="meta">@Param(&quot;orderIds&quot;)</span>List&lt;Long&gt; orderIds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        Long id = i + <span class="number">1L</span>;</span><br><span class="line">        userDao.insertUser(id,<span class="string">&quot;姓名&quot;</span>+ id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUserbyIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Long&gt; userIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    userIds.add(<span class="number">1L</span>);</span><br><span class="line">    userIds.add(<span class="number">2L</span>);</span><br><span class="line">    List&lt;Map&gt; users = userDao.selectUserbyIds(userIds);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Sharding-JDBC执行流程：<code>SQL解析 =&gt; 查询优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt; 结果归并</code></p>
<p>系统在设计之初就应该对业务数据的耦合松紧进行考量，从而进行垂直分库、垂直分表，使数据层架构清晰明了。 </p>
<p>若非必要，无需进行水平切分，应先从缓存技术着手降低对数据库的访问压力。如果缓存使用过后，数据库访问量还是非常大，可以考虑数据库读、写分离原则。若当前数据库压力依然大，且业务数据持续增长无法估量，最后可考虑水平分库、分表，单表拆分数据控制在1000万以内。 </p>
<p>注意：并不是所有的sql语句都能支持执行</p>
<p>详细参考：<a href="https://shardingsphere.apache.org/document/current/cn/features/sharding/use-norms/sql/">https://shardingsphere.apache.org/document/current/cn/features/sharding/use-norms/sql/</a></p>
]]></content>
      <tags>
        <tag>分库分表</tag>
        <tag>多数据源</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型模式-原型模式</title>
    <url>/2022/05/21/0.2.3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>原型模式是指，一个抽象类 <code>Prototype</code> 具有一个<code>clone</code> 方法，其实现类<code>ConcretePrototype1</code>、<code>ConcretePrototype2</code> 实现各自的clone方法，在使用的时候，调用Prototype的clone方法可以clone任意实现类。其作用就是快速创建一个新的对象</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/30/164e896061e7bc95~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h3 id="Prototype（抽象原型类）："><a href="#Prototype（抽象原型类）：" class="headerlink" title="Prototype（抽象原型类）："></a>Prototype（抽象原型类）：</h3><p>它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p>
<h3 id="ConcretePrototype（具体原型类）："><a href="#ConcretePrototype（具体原型类）：" class="headerlink" title="ConcretePrototype（具体原型类）："></a>ConcretePrototype（具体原型类）：</h3><p>它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>
<h3 id="Client（客户类）："><a href="#Client（客户类）：" class="headerlink" title="Client（客户类）："></a>Client（客户类）：</h3><p>让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p>
<h2 id="何时使用原型模式"><a href="#何时使用原型模式" class="headerlink" title="何时使用原型模式"></a>何时使用原型模式</h2><ul>
<li>需要创建的对象应独立于其类型与创建方式</li>
<li>要实例化的类是在运行时决定的</li>
<li>类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易</li>
<li>从功能的角度来讲，不管什么对象，只要复制自身比手工实例化要好，都可以是原型对象</li>
<li>不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便</li>
<li>需要使用组合(树型)对象作为其他东西的基础。例如，使用组合对象作为组件来构建另一个组合对象</li>
</ul>
<h2 id="原型模式原理"><a href="#原型模式原理" class="headerlink" title="原型模式原理"></a>原型模式原理</h2><p>一个原型类，只需要实现<code>Cloneable</code>接口，覆写<code>clone</code>方法，此处<code>clone</code>方法可以改成任意的名称，因为<code>Cloneable</code>接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是<code>super.clone()</code>这句话，<code>super.clone()</code>调用的是Object的clone()方法，而在Object类中，clone()是native的<br>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，<code>Java编译器将抛出一个CloneNotSupportedException异常。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span>  <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">……</span><br><span class="line"><span class="function"><span class="keyword">public</span> Prototype  <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　Object object = <span class="keyword">null</span>;</span><br><span class="line">　　<span class="keyword">try</span> &#123;</span><br><span class="line">　　　　　object = <span class="keyword">super</span>.clone();</span><br><span class="line">　　&#125; <span class="keyword">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class="line">　　　　　System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> (Prototype )object;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端创建原型对象和克隆对象也很简单，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Prototype obj1  = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">Prototype obj2  = obj1.clone();</span><br></pre></td></tr></table></figure>

<p>一般而言，Java语言中的clone()方法都需要满足：</p>
<ul>
<li>对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</li>
<li>对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</li>
<li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。<br>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</li>
<li>在派生类中覆盖基类的clone()方法，并声明为public；</li>
<li>在派生类的clone()方法中，调用super.clone()；</li>
<li>派生类需实现Cloneable接口。<br>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</li>
</ul>
<h2 id="浅拷贝-ShallowClone-和深拷贝-DeepClone-介绍"><a href="#浅拷贝-ShallowClone-和深拷贝-DeepClone-介绍" class="headerlink" title="浅拷贝(ShallowClone)和深拷贝(DeepClone)介绍"></a>浅拷贝(ShallowClone)和深拷贝(DeepClone)介绍</h2><ul>
<li>浅拷贝<br>在浅拷贝中，如果原型对象的成员变量是值类型，将复制一份给拷贝对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给拷贝对象，也就是说原型对象和拷贝对象的成员变量指向相同的内存地址。简单来说，在浅拷贝中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制<br><img src="https://static.sitestack.cn/projects/design-pattern-java/e819192d3af8ff629bc3bd59178331ae.gif" alt="img"></li>
<li>深拷贝<br>在深拷贝中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给拷贝对象，深拷贝将原型对象的所有引用对象也复制一份给拷贝对象。简单来说，在深拷贝中，除了对象本身被复制外，对象所包含的所有成员变量也将复制<br><img src="https://static.sitestack.cn/projects/design-pattern-java/1a947f62d159593806d1c30cf8b0ac23.gif" alt="img"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> ExpenseDetail detail;<span class="comment">//消费明细</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行构造函数Message&quot;</span>);</span><br><span class="line">        detail = <span class="keyword">new</span> ExpenseDetail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String name, String type,<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.detail.setType(type);</span><br><span class="line">        <span class="keyword">this</span>.detail.setMoney(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            message = (Message) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">&quot;您好：您今天&quot;</span>+detail.getType()+<span class="string">&quot;消费了&quot;</span>+detail.getMoney()+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费明细</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpenseDetail</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MbClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setMessage(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;吃饭&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Message message1 = message.clone();</span><br><span class="line">        message1.setMessage(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;看电影&quot;</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        Message message2 = message.clone();</span><br><span class="line">        message2.setMessage(<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;买书&quot;</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        message.sendMessage();</span><br><span class="line">        message1.sendMessage();</span><br><span class="line">        message2.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">执行构造函数Message</span><br><span class="line">张三您好：您今天买书消费了<span class="number">100.0</span>元</span><br><span class="line">李四您好：您今天买书消费了<span class="number">100.0</span>元</span><br><span class="line">王五您好：您今天买书消费了<span class="number">100.0</span>元</span><br></pre></td></tr></table></figure>

<p>我们可以看到所有人的消费明细居然都一样，这是因为Object类提供的clone方法，不会拷贝对象中的内部数组和引用对象，导致它们仍旧指向原来对象的内部元素地址，这种拷贝叫做浅拷贝。</p>
<blockquote>
<p>由此而导致最后一次的值会覆盖前一次的值。<br>此时的<code>message.getDetail = message1.getDetail =message2.getDetail</code></p>
</blockquote>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝方式有两种:<code>继承cloneable</code>或者进行<code>Serializable</code></p>
<h3 id="继承cloneable接口"><a href="#继承cloneable接口" class="headerlink" title="继承cloneable接口"></a>继承cloneable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            message = (Message) <span class="keyword">super</span>.clone();</span><br><span class="line">            message.detail = <span class="keyword">this</span>.detail.clone();<span class="comment">//拷贝消费明细</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpenseDetail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ExpenseDetail <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ExpenseDetail detail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            detail = (ExpenseDetail) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> detail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">结果</span><br><span class="line">执行构造函数Message</span><br><span class="line">张三您好：您今天吃饭消费了<span class="number">10.0</span>元</span><br><span class="line">李四您好：您今天看电影消费了<span class="number">50.0</span>元</span><br><span class="line">王五您好：您今天买书消费了<span class="number">100.0</span>元</span><br></pre></td></tr></table></figure>

<p>此时的<code>message.getDetail != message1.getDetail !=message2.getDetail</code></p>
<h3 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.io.*;</span><br><span class="line"><span class="comment">//附件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="keyword">private</span>  String name; <span class="comment">//附件名</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.name  = name;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  <span class="keyword">this</span>.name;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;下载附件，文件名为&quot;</span> + name);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.io.*;</span><br><span class="line"><span class="comment">//工作周报类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">WeeklyLog</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="keyword">private</span>  Attachment attachment;</span><br><span class="line">       <span class="keyword">private</span>  String name;</span><br><span class="line">       <span class="keyword">private</span>  String date;</span><br><span class="line">       <span class="keyword">private</span>  String content;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setAttachment</span><span class="params">(Attachment attachment)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.attachment  = attachment;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.name  = name;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.date  = date;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.content  = content;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  Attachment <span class="title">getAttachment</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="keyword">this</span>.attachment);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="keyword">this</span>.name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  String <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="keyword">this</span>.date);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  (<span class="keyword">this</span>.content);</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">//使用序列化技术实现深克隆</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> WeeklyLog <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span>  IOException, ClassNotFoundException, OptionalDataException</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              <span class="comment">//将对象写入流中</span></span><br><span class="line">              ByteArrayOutputStream bao=<span class="keyword">new</span>  ByteArrayOutputStream();</span><br><span class="line">              ObjectOutputStream oos=<span class="keyword">new</span>  ObjectOutputStream(bao);</span><br><span class="line">              oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//将对象从流中取出</span></span><br><span class="line">              ByteArrayInputStream bis=<span class="keyword">new</span>  ByteArrayInputStream(bao.toByteArray());</span><br><span class="line">              ObjectInputStream ois=<span class="keyword">new</span>  ObjectInputStream(bis);</span><br><span class="line">              <span class="keyword">return</span>  (WeeklyLog)ois.readObject();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作周报类WeeklyLog不再使用Java自带的克隆机制，而是通过序列化来从头实现对象的深克隆，所以我们需要重新编写clone()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              WeeklyLog  log_previous, log_new = <span class="keyword">null</span>;</span><br><span class="line">              log_previous  = <span class="keyword">new</span> WeeklyLog(); <span class="comment">//创建原型对象</span></span><br><span class="line">              Attachment  attachment = <span class="keyword">new</span> Attachment(); <span class="comment">//创建附件对象</span></span><br><span class="line">              log_previous.setAttachment(attachment);  <span class="comment">//将附件添加到周报中</span></span><br><span class="line">              <span class="keyword">try</span></span><br><span class="line">              &#123;</span><br><span class="line">                     log_new =  log_previous.deepClone(); <span class="comment">//调用深克隆方法创建克隆对象                  </span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span>(Exception e)</span><br><span class="line">              &#123;</span><br><span class="line">                     System.err.println(<span class="string">&quot;克隆失败！&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//比较周报</span></span><br><span class="line">              System.out.println(<span class="string">&quot;周报是否相同？ &quot;</span> + (log_previous ==  log_new));</span><br><span class="line">              <span class="comment">//比较附件</span></span><br><span class="line">              System.out.println(<span class="string">&quot;附件是否相同？ &quot;</span> +  (log_previous.getAttachment() == log_new.getAttachment()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">周报是否相同？  <span class="keyword">false</span></span><br><span class="line">附件是否相同？  <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>此情况下：不论是基本数据类型还有引用类型，都是重新创建的</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<p>原型模式是在内存中二进制流的拷贝，要比new一个对象的性能要好，特别是需要生产大量对象时</p>
</blockquote>
<p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。<br>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。<br>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。<br>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<p>直接在内存中拷贝，构造函数是不会执行的，这样就减少了约束，既是优点也是缺点，在实际开发当中应注意这个问题</p>
</blockquote>
<p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。<br>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。<br>(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。<br>(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便</p>
<h2 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h2><ul>
<li>克隆是否调用构造器方法？<br>不会，clone方法直接复制内存中的二进制，效率高</li>
<li>克隆出的对象和之前的是否一致？<br>不一致，但是浅拷贝下引用类型对象是一致的（因为指向同一份地址），深拷贝下不一致</li>
<li>改变克隆对象的值，原对象是否会变？<br>基本类型不变，引用类型随之改变</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.runoob.com/design-pattern/prototype-pattern.html">原型模式 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="https://www.bookstack.cn/read/design-pattern-java/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89.md">原型模式-Prototype Pattern - 对象的克隆——原型模式（一） - 《设计模式 Java版本》 - 书栈网 · BookStack</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/343917614">设计模式之什么是原型模式 - 知乎 (zhihu.com)</a></li>
<li><a href="https://juejin.cn/post/6844903648405749767">设计模式：原型模式 - 掘金 (juejin.cn)</a></li>
<li><a href="https://juejin.cn/post/6844904021258403854">设计模式-原型模式 - 掘金 (juejin.cn)</a></li>
<li><a href="https://www.nowcoder.com/discuss/151692?type=all&order=recall&pos=&page=0&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=6646713B267797EE31FEA69CC7FFC4BD-1652844493925">设计模式实战 - 原型模式_技术交流_牛客网 (nowcoder.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/388259961">看完就明白的原型模式 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/A1342772/article/details/91349142">23 种设计模式详解（全23种）_鬼灭之刃的博客-CSDN博客_设计模式</a></li>
<li><a href="https://www.cnblogs.com/geek6/p/3951677.html">23种设计模式全解析 - codeTao - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA插件</title>
    <url>/2022/05/09/0.2.2IDEA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="插件官网"><a href="#插件官网" class="headerlink" title="插件官网"></a>插件官网</h2><p><a href="https://plugins.jetbrains.com/">JetBrains Marketplace</a></p>
<h2 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h2><p>首先要推荐的是和《手册》配套的 <a href="https://link.zhihu.com/?target=https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines">阿里巴巴 Java代码规范</a>插件。<br>安装该插件后，代码超过 80 行、手动创建线程池等，这些和《手册》中的规约不符时，IDEA中会给出警告提示。</p>
<h2 id="jclasslib-bytecode-viewer"><a href="#jclasslib-bytecode-viewer" class="headerlink" title="jclasslib bytecode viewer"></a>jclasslib bytecode viewer</h2><p>下面要隆重介绍的是一款可视化的字节码查看插件：<a href="https://link.zhihu.com/?target=https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer">jclasslib</a><br>大家可以直接在 IDEA 插件管理中安装（安装步骤略）<br><strong>使用方法：</strong></p>
<ol>
<li>在 IDEA 打开想研究的类</li>
<li>编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）</li>
<li>打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项</li>
<li>选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口<br><img src="https://gitee.com/foam077/images/raw/master/img/8e553cce-1641-4005-a6ff-6a3d37b0ac09.jpg/" alt="img"><br>那么有自带的强大的反汇编工具 javap 还有必要用这个插件吗？<br>这个插件的强大之处在于：</li>
<li>不需要敲命令，简单直接，在右侧方便和源代码进行对比学习。</li>
<li>字节码命令支持超链接，点击其中的虚拟机指令即可跳转到 jvms 相关章节，超级方便。<br>该插件对我们学习虚拟机指令有极大的帮助。<br>详细安装和介绍参考另外一篇手记：<a href="https://www.imooc.com/article/29625">https://www.imooc.com/article/29625</a></li>
</ol>
<h2 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h2><p>另外一个不得不说的就是专栏中提到的辅助开发神器: <a href="https://link.zhihu.com/?target=https://www.codota.com/code">Codota</a><br>可以点击下图所示“Add Codota to you IDEA” 了解安装步骤<br><img src="https://gitee.com/foam077/images/raw/master/img/7916b83c-b22f-4cc4-87c1-e6baf8dd31d3.png/" alt="img"><br>该插件的强大之处在于：</p>
<ol>
<li>支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能。</li>
<li>支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法<br>当我们第一次使用某个类，对某个函数不够熟悉时，可以通过该插件搜索相关用法，快速模仿学习<br><img src="https://gitee.com/foam077/images/raw/master/img/8351c384-572e-4e28-9c8b-22249fd90af2.jpg/" alt="img"><br>如上图所示，我们想了解 Stream 类中 flatMap 函数的用法，可以使用该插件查看知名开源项目的用法<br>插件窗口顶部还给出了该类最常用的函数，可以点击查看相关用法案例，每个案例右侧的 “view source”可以跳转到该片段对应的开源项目的源码中</li>
</ol>
<h2 id="Auto-filling-Java-call-arguments"><a href="#Auto-filling-Java-call-arguments" class="headerlink" title="Auto filling Java call arguments"></a>Auto filling Java call arguments</h2><p>开发中，我们通常会调用其他已经编写好的函数，调用后需要填充参数，但是绝大多数情况下，传入的变量名称和该函数的参数名一致，当参数较多时，手动单个填充参数非常浪费时间<br>该插件就可以帮你解决这个问题<br>安装完该插件以后，调用一个函数，使用 Alt+Enter 组合键，调出 “Auto fill call parameters” 自动使用该函数定义的参数名填充</p>
<h2 id="GenerateO2O、GenerateAllSetter"><a href="#GenerateO2O、GenerateAllSetter" class="headerlink" title="GenerateO2O、GenerateAllSetter"></a>GenerateO2O、GenerateAllSetter</h2><p>我们定义好从 A 类转换到 B 类的函数转换函数后，使用这两个插件可以自动调用 Getter 和 Setter 函数实行自动转换<br>实际开发中还有一个非常常见的场景： 我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复<br><img src="https://gitee.com/foam077/images/raw/master/img/c66fd122-cab4-47cc-b961-c135cd4959a4.jpg/" alt="img"><br>可以使用这 GenerateAllSetter 提供的功能，自动调用所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值</p>
<h2 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h2><p>由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦<br>痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙<br>插件 github 地址：<a href="https://github.com/izhangzhihao/intellij-rainbow-brackets">https://github.com/izhangzhihao/intellij-rainbow-brackets</a><br><img src="https://gitee.com/foam077/images/raw/master/img/fb0eecd3-58fb-4c94-983b-0c857429b1af.jpg/" alt="img"><br>大家可以观看其 github 首页的动图体会和学习其强大功能</p>
<h2 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h2><p>现在 Java 项目通常会使用 maven 或者 gradle 构建，对于maven 项目来说， jar 包冲突非常常见<br>那么如何更容易地查看和解决 jar 包冲突呢？<br><img src="https://gitee.com/foam077/images/raw/master/img/6d4402db-659a-46a5-a3c5-2eca8e2d8fef.jpg/" alt="img"><br>大家可以安装该插件，安装后 IDEA 中打开 pom.xml 文件时，就会多出一个 “Dependency Analyzer” 选项卡<br>如上图所示，该插件支持值插件冲突的 jar 包，可以选择冲突的 jar 包将其 exclude 掉</p>
<h2 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h2><p>程序员总是想尽可能地避免写 BUG， <a href="https://link.zhihu.com/?target=https://plugins.jetbrains.com/plugin/3847-findbugs-idea">FindBugs</a> 作为静态代码检查插件，可以检查你代码中的隐患，并给出原因。<br><img src="https://gitee.com/foam077/images/raw/master/img/7a194699-57ed-4fa2-90dc-0ea77f6387aa.jpg/" alt="img"><br>当然还有很多类似的静态代码检查插件，大家可以自行了解安装</p>
<h2 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h2><p><a href="https://link.zhihu.com/?target=https://plugins.jetbrains.com/plugin/8286-sequencediagram/">SequenceDiagram</a> 可以根据代码调用链路自动生成时序图，超级赞，超级推荐！<br>这对研究源码，梳理工作中的业务代码有极大的帮助，堪称神器。<br>安装完成后，在某个类的某个函数中，右键 –Sequence Diagaram 即可调出。<br>如下图是 Netty 的源码，可以通过该插件绘制出当前函数的调用链路。<br><img src="https://gitee.com/foam077/images/raw/master/img/9fcf9f6f-fca3-4e84-bde3-4fcae1d094cc.jpg/" alt="img"><br>双击顶部的类名可以跳转到对应类的源码中，双击调用的函数名可以直接调入某个函数的源码，总之非常强大。</p>
<h2 id="Java-Stream-Debugger"><a href="#Java-Stream-Debugger" class="headerlink" title="Java Stream Debugger"></a>Java Stream Debugger</h2><p>Stream 非常好用，可以灵活对数据进行操作，但是对很多刚接触的人来说，不好理解。<br>那么 <a href="https://link.zhihu.com/?target=https://plugins.jetbrains.com/plugin/9696-java-stream-debugger/">Java Stream Debugger</a> 这款神器的 IDEA 就可以帮到你。它可以将 Stream 的操作步骤可视化，非常有助于我们的学习。<br><img src="https://gitee.com/foam077/images/raw/master/img/8ca3318a-0e7c-41a5-aeca-9fdd2f22fe64.png/" alt="img"><br><img src="https://gitee.com/foam077/images/raw/master/img/65dd07a0-1d0e-44e7-aa53-6d5214f41b67.png/" alt="img"></p>
<h2 id="Key-promoter-X"><a href="#Key-promoter-X" class="headerlink" title="Key promoter X"></a>Key promoter X</h2><p>很多人不愿意切换 IDE 就是因为快捷键的习惯问题。刚好这个插件可以提醒快捷键，有代入感，提醒的多了你就会了。对于新手建议安装熟悉一下快捷键。<br><img src="https://gitee.com/foam077/images/raw/master/img/9c228208-bfc5-4266-9237-e6667719476d.gif/" alt="img"></p>
<h2 id="IDEA-Mind-Map"><a href="#IDEA-Mind-Map" class="headerlink" title="IDEA Mind Map"></a>IDEA Mind Map</h2><p>思维导图对于我们需求分析和知识库关系梳理十分重要。有了这个插件以后 IDEA 也可以画思维导图了。而且功能还十分强大，贴图啥的应有尽有<br><img src="https://gitee.com/foam077/images/raw/master/img/fdeb2a29-dadd-46a8-8470-9dcaed28f538.jpg/" alt="img"></p>
<h2 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h2><p>代码编辑区迷你缩放插件，可以进行代码的全局预览。来看看效果吧<br><img src="https://gitee.com/foam077/images/raw/master/img/8201434c-1af4-4541-814d-3319272e9dce.jpg/" alt="img"></p>
<h2 id="CamelCase"><a href="#CamelCase" class="headerlink" title="CamelCase"></a>CamelCase</h2><p>命名风格转换插件，可以在 kebab-case，SNAKE_CASE，PascalCase，camelCase，snake_case 和 空格风格之间切换。快捷键苹果为 ⇧+⌥+ U ，windows 下为 Shift + Alt +U<br><img src="https://gitee.com/foam077/images/raw/master/img/fc0c56ed-3faa-4561-a62a-79972d781f99.jpg/" alt="img"></p>
<h2 id="MybatisX"><a href="#MybatisX" class="headerlink" title="MybatisX"></a>MybatisX</h2><p>Mybatis-plus 团队为 Mybatis 开发的插件，提供了 Mapper 接口和 XML之间的跳转和自动生成模版的功能<br><img src="https://gitee.com/foam077/images/raw/master/img/049c45ce-b90f-4dd7-9a93-66ac59bba065.jpg/" alt="img"></p>
<h2 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a>MyBatis Log Plugin</h2><p>另一款国人关于 Mybatis 的作品，评分也很高，作用是将 Mybatis 生成的 sql 还原为原始整个 sql。方便在开发中从日志中跟踪调试 sql语句<br><a href="https://vdn.vzuu.com/SD/04205f24-23a2-11eb-a602-d6a043673cc5.mp4?disable_local_cache=1&amp;bu=078babd7&amp;c=avc.0.0&amp;f=mp4&amp;expiration=1652064414&amp;auth_key=1652064414-0-0-ed4dc28442589dc4e9e6703457fc9811&amp;v=ali&amp;pu=078babd7">https://vdn.vzuu.com/SD/04205f24-23a2-11eb-a602-d6a043673cc5.mp4?disable_local_cache=1&amp;bu=078babd7&amp;c=avc.0.0&amp;f=mp4&amp;expiration=1652064414&amp;auth_key=1652064414-0-0-ed4dc28442589dc4e9e6703457fc9811&amp;v=ali&amp;pu=078babd7</a></p>
<h2 id="Git-Commit-Template"><a href="#Git-Commit-Template" class="headerlink" title="Git Commit Template"></a>Git Commit Template</h2><p>老是有人吐槽你提交的 Git 不规范？你可以试试这个插件。它提供了很好的 Git 格式化模版，你可以按照实际情况格式化你的提交信息<br><img src="https://gitee.com/foam077/images/raw/master/img/4dec18c9-6b03-433c-a1e1-3c89624e4e9f.jpg/" alt="img"></p>
<h2 id="Fast-Request"><a href="#Fast-Request" class="headerlink" title="Fast Request"></a>Fast Request</h2><p>Fast Request是一个基于springmvc的帮助你快速生成url和参数的插件,同时也是一个http client工具,调试API的时候只需要点击生成图标即可在工具窗口生成方法的url以及对应的参数，再点击发送请求按钮即可完成api调试，非常实用，相比于 Http client和restfultool，该插件拥有postman一样的界面和参数生成功能，域名管理功能，自定义参数解析功能，功能更加强大全面<br>【缺点】收费<br><img src="https://gitee.com/foam077/images/raw/master/img/b2cdd37b-7b10-468b-a35d-68489cda7605.png/" alt="img"></p>
<h2 id="Easy-Javadoc"><a href="#Easy-Javadoc" class="headerlink" title="Easy Javadoc"></a>Easy Javadoc</h2><p>快速生成javadoc文档，点击快捷键生成方法或类或属性的javadoc，同时支持各种渠道的翻译(建议不要用有道翻译，不准)<br><img src="https://gitee.com/foam077/images/raw/master/img/d11428a5-ae8e-46a1-963b-5b84466de68c.png/" alt="img"></p>
<h2 id="MybatisCodeHelperPro"><a href="#MybatisCodeHelperPro" class="headerlink" title="MybatisCodeHelperPro"></a>MybatisCodeHelperPro</h2><p>最好的Mybatis代码提示，完整支持Mybatis动态sql代码提示，代码检测，写sql几乎所有地方都有代码提示，支持基于方法名动态生成sql，生成基础实体类及mapper，功能非常强大<br><img src="https://gitee.com/foam077/images/raw/master/img/ac025a3e-6f41-45d5-b9a5-0aad8b58c91d.png/" alt="img"><br><img src="https://gitee.com/foam077/images/raw/master/img/c7d441d0-5520-4439-a385-ec72cd94b848.png/" alt="img"></p>
<h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>对于英文不好的开发者来说，这款插件就是神器，在看各种框架源码的时候十分有用; 选择右键就可以翻译，对于方法或者类上面的注释，只要按下F1就自动被翻译成中文<br>(建议自定义快捷键)<br><img src="https://gitee.com/foam077/images/raw/master/img/9d5f6612-6196-467f-9e20-90a91ecdf4ad.png/" alt="img"></p>
<h2 id="Jrebel"><a href="#Jrebel" class="headerlink" title="Jrebel"></a>Jrebel</h2><p>老牌插件了，支持热启动，修改一些代码不再需要重启应用，大大减小项目重启带来的时间浪费，同时也支持远程启动调试<br><img src="https://gitee.com/foam077/images/raw/master/img/14cc8906-e2a1-40e8-8a07-b22d04b267e9.png/" alt="img"></p>
<h2 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h2><p>.ignore是IDEA的一款专用忽略文件的插件<br><img src="https://gitee.com/foam077/images/raw/master/img/73ede4ce-3971-4c68-abf7-1deefeb78152.png/" alt="img"></p>
<h2 id="google-java-format"><a href="#google-java-format" class="headerlink" title="google-java-format"></a>google-java-format</h2><p>google-java-format插件可以帮助我们不通过对应的快捷键就可以实现特定方式下自动格式化代码</p>
<h2 id="Leetcode-Editor"><a href="#Leetcode-Editor" class="headerlink" title="Leetcode Editor"></a>Leetcode Editor</h2><p>LeetCode插件，可以在IDEA中在线刷题。上班摸鱼属实方便，表面上我在干活，实际上我在刷算法题<br><img src="https://gitee.com/foam077/images/raw/master/img/7f7c5086-3d6a-4794-941e-b77d02a8a01c.png/" alt="img"></p>
<h2 id="Json-Parser"><a href="#Json-Parser" class="headerlink" title="Json Parser"></a>Json Parser</h2><p>厌倦了打开浏览器格式化和验证JSON?为什么不安装JSON解析器并在IDE中使用离线支持呢?JSON解析器是一个用于验证和格式化JSON字符串的轻量级插件<br><img src="https://gitee.com/foam077/images/raw/master/img/11aa823f-4418-4d35-aeb9-c561d32ef62f.png/" alt="img"></p>
]]></content>
      <tags>
        <tag>idea</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP解决内部方法调用不生效问题</title>
    <url>/2022/05/28/0.2.4-AOP%E8%A7%A3%E5%86%B3%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>描述：在使用AOP切面的时候Controller层可以正常切入进去，但是Service层内部方法调用切入不进去</p>
</blockquote>
<h2 id="大致情况"><a href="#大致情况" class="headerlink" title="大致情况"></a>大致情况</h2><p>就算打注解放methodB上也不会进切面，Aop只支持外部调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gufung</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAopService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method A run&quot;</span>);</span><br><span class="line">        <span class="comment">//内部调用方法B时AOP的增强处理方法不会执行</span></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method B run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><h3 id="1-配置spring-context-xml"><a href="#1-配置spring-context-xml" class="headerlink" title="1.配置spring-context.xml"></a>1.配置spring-context.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 通过<span class="meta">@Aspect</span>注解实现AOP --&gt;</span><br><span class="line">&lt;!-- proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;true&quot;</span>表示使用CGlib动态代理 --&gt;</span><br><span class="line">&lt;!-- expose-proxy=<span class="string">&quot;true&quot;</span>暴露代理对象 --&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;true&quot;</span> expose-proxy=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用AopContext-currentProxy-获取代理对象方法，并且执行"><a href="#2-使用AopContext-currentProxy-获取代理对象方法，并且执行" class="headerlink" title="2.使用AopContext.currentProxy()获取代理对象方法，并且执行"></a>2.使用AopContext.currentProxy()获取代理对象方法，并且执行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.AopContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gufung</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAopService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method A run&quot;</span>);</span><br><span class="line">        <span class="comment">//methodB();</span></span><br><span class="line">        <span class="comment">//从spring上下文获取代理对象执行方法</span></span><br><span class="line">        ((TestAopService) AopContext.currentProxy()).methodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method B run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>methodB一定要声明为<code>public</code> 否则进不去切面！！！</p>
<h2 id="注解实现方法计时"><a href="#注解实现方法计时" class="headerlink" title="注解实现方法计时"></a>注解实现方法计时</h2><h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 耗时统计</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Foam</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TimeComsumingStatics &#123;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-aop"><a href="#2-aop" class="headerlink" title="2.aop"></a>2.aop</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeComsumingAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(TimeComsumingAOP.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;timeCusming:false&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String openButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于注解定义切入点</span></span><br><span class="line"><span class="comment">     * 对于注解了 <span class="doctag">@TimeComsumingStatics</span>的方法进行拦截</span></span><br><span class="line"><span class="comment">     * 表示标注了特定注解的目标方法链接点。如<span class="doctag">@annotation</span>(com.dw.study.TestAnnotation)表示任何标注了<span class="doctag">@TestAnnotation</span>注解的目标类方法。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.service.zl.vo.TimeComsumingStatics)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务记录执行日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;aspect() &amp;&amp; @annotation(timeComsumingStatics)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">before</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint,TimeComsumingStatics timeComsumingStatics)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;true&quot;</span>.equals(openButton))&#123;</span><br><span class="line">            <span class="keyword">long</span> actStartTime = System.currentTimeMillis();</span><br><span class="line">            Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="keyword">long</span> actEndTime = System.currentTimeMillis();</span><br><span class="line">            String timecusming = (actEndTime - actStartTime)  + <span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">            log.info(timeComsumingStatics.methodName() + <span class="string">&quot;耗时：&quot;</span> + timecusming);</span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> proceedingJoinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-application-properties"><a href="#3-application-properties" class="headerlink" title="3.application.properties"></a>3.application.properties</h3><p>当timeCusming为true时开启接口耗时统计，false反之</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">timeCusming=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-注解使用"><a href="#4-注解使用" class="headerlink" title="4.注解使用"></a>4.注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.AopContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gufung</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAopService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method A run&quot;</span>);</span><br><span class="line">        <span class="comment">//methodB();</span></span><br><span class="line">        <span class="comment">//从spring上下文获取代理对象执行方法</span></span><br><span class="line">        ((TestAopService) AopContext.currentProxy()).methodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TimeComsumingStatics(methodName = &quot;调用methodB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method B run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-结果"><a href="#5-结果" class="headerlink" title="5.结果"></a>5.结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用methodB耗时：<span class="number">17</span>毫秒</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p><a href="https://blog.csdn.net/Azhuzhu_chaste/article/details/107284821">AOP内部调用失效-解决方法_咕了个咕的博客-CSDN博客_aop 内部调用</a></p>
<p>注意：jdk1.8的default才能使用接口方式</p>
</li>
<li><p><a href="https://blog.csdn.net/code_my_life/article/details/51891520">Java 8 interface default方法_Code_My_Life的博客-CSDN博客_interface的default方法</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/jvStarBlog/p/11130233.html">spring–aop内部调用失效问题分析 - 11014p - 博客园</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>定时任务使用总结</title>
    <url>/2022/04/04/0.0.2%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>相信定时任务大家都不陌生，可能在个人项目中使用定时任务会比较少，但是在业务复杂的公司中，定时任务是不可或缺的一部分，有时候也可以贯穿整个项目的流程运转。</p>
<h1 id="什么是定时任务"><a href="#什么是定时任务" class="headerlink" title="什么是定时任务"></a>什么是定时任务</h1><p>crond类似于我们平时生活中的闹钟，可以定时叫你起床，而在项目中就是定时执行一段指定的代码</p>
<p><strong>为什么要使用crond呢</strong></p>
<p>1.如果对于一些数据实时性要求没那么高，我们可以把数据提前丢到缓存中，这个时候就需要使用定时任务去跑了，比如每天凌晨3点定时把数据同步到缓存，错峰同步避开白天人流量大的时候消耗资源</p>
<p>2.比如凌晨2点有抢购接口/或者业务开关需要进行变更开启，我们可以使用定时任务去进行变更，不用人为去守着变更，而且执行时间更准确（可以滚去睡大觉.jpg）</p>
<p>3.还可以进行数据的定时备份，比如备份配置文件，防止宕机的时候配置文件的恢复等等</p>
<h1 id="定时任务实现方式"><a href="#定时任务实现方式" class="headerlink" title="定时任务实现方式"></a>定时任务实现方式</h1><h2 id="1-Thread"><a href="#1-Thread" class="headerlink" title="1.Thread"></a>1.Thread</h2><p>各位亲爱的朋友，没错，Thread真的可以做定时任务.</p>
<p>如果你去看过一些定时任务框架的源码，它们的底层也会使用Thread类（需要注意用try……catch捕获异常，否则出现异常，就直接退出循环）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;doSameThing&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：比如项目中有时需要每隔10分钟去下载某个文件，或者每隔5分钟去读取模板文件生成静态html页面等等，一些简单的周期性任务场景。</p>
<p>优缺点：</p>
<ul>
<li>优点：这种定时任务非常简单，学习成本低，容易入手，对于那些简单的周期性任务，是个不错的选择。</li>
<li>缺点：不支持指定某个时间点执行任务，不支持延迟执行等操作，功能过于单一，无法应对一些较为复杂的场景。</li>
</ul>
<h2 id="2-Timer"><a href="#2-Timer" class="headerlink" title="2.Timer"></a>2.Timer</h2><p>Timer 类是jdk专门提供的定时器工具，用来在后台线程计划执行指定任务，在 java.util 包下，要跟 TimerTask 一起配合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Timer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    <span class="comment">// 1.需要执行的内容</span></span><br><span class="line">    <span class="comment">// 2.延时多久执行</span></span><br><span class="line">    <span class="comment">// 3.执行周期</span></span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="number">123</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">200</span>,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<ul>
<li>优点：非常方便实现多个周期性的定时任务，并且支持延迟执行，还支持在指定时间之后支持，功能还算强大。</li>
<li>缺点：如果其中一个任务耗时非常长，会影响其他任务的执行。并且如果 TimerTask 抛出 RuntimeException ， Timer 会停止所有任务的运行，所以<code>阿里巴巴开发者规范中不建议使用它</code></li>
</ul>
<h2 id="3-Scheduled-注解（常用）"><a href="#3-Scheduled-注解（常用）" class="headerlink" title="3.Scheduled 注解（常用）"></a>3.Scheduled 注解（常用）</h2><p>由于xml方式太古老了，我们以springboot项目中注解方式为例</p>
<p>1.引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在springboot启动类上加上 @EnableScheduling 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.使用 @Scheduled 注解定义定时规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronJob</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoGetMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当期执行时间：&quot;</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<ul>
<li>优点：<code>采用cron表达式，比较方便</code>，spring框架自带的定时功能，springboot做了非常好的封装，开启和定义定时任务非常容易，可以满足绝大多数单机版的业务场景。单个任务时，当前次的调度完成后，再执行下一次任务调度。</li>
<li>默认单线程，如果前面的任务执行时间太长，对后面任务的执行有影响。不支持集群方式部署，不能做数据存储型定时任务。</li>
</ul>
<h2 id="5-spring-quartz（常用）"><a href="#5-spring-quartz（常用）" class="headerlink" title="5.spring quartz（常用）"></a>5.spring quartz（常用）</h2><p>quartz 是 OpenSymphony 开源组织在 Job scheduling 领域的开源项目，是由java开发的一个开源的任务日程管理系统。</p>
<p>quartz能做什么？</p>
<ul>
<li>作业调度：调用各种框架的作业脚本，例如shell,hive等。</li>
<li>定时任务：在某一预定的时刻，执行你想要执行的任务</li>
</ul>
<p>1.引入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.定时任务执行类继承QuartzJobBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//获取JobDetail中关联的数据</span></span><br><span class="line">        String msg = (String) jobExecutionContext.getJobDetail().getJobDataMap().get(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;current time :&quot;</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()) + <span class="string">&quot;---&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.调度配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">printTimeJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(DateTimeJob.class)<span class="comment">//PrintTimeJob我们的业务类</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;DateTimeJob&quot;</span>)<span class="comment">//可以给该JobDetail起一个id</span></span><br><span class="line">                <span class="comment">//每个JobDetail内都有一个Map，包含了关联到这个Job的数据，在Job类中可以通过context获取</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello Quartz&quot;</span>)<span class="comment">//关联键值对</span></span><br><span class="line">                .storeDurably()<span class="comment">//即使没有Trigger关联时，也不需要删除该JobDetail</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">printTimeJobTrigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/1 * * * * ?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(printTimeJobDetail())<span class="comment">//关联上述的JobDetail</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;quartzTaskService&quot;</span>)<span class="comment">//给Trigger起个名字</span></span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<ul>
<li>优点：默认是多线程异步执行，单个任务时，在上一个调度未完成时，下一个调度时间到时，会另起一个线程开始新的调度，多个任务之间互不影响。支持复杂的 cron 表达式，它能被集群实例化，支持分布式部署</li>
<li>缺点：相对于spring task实现定时任务成本更高，需要手动配置 QuartzJobBean 、 JobDetail和 Trigger 等。需要引入了第三方的 quartz 包，有一定的学习成本。不支持并行调度，不支持失败处理策略和动态分片的策略等。</li>
</ul>
<p>以下两种配置参考方式</p>
<p><a href="https://blog.csdn.net/userlhj/article/details/89510837">springXML配置方式</a></p>
<p><a href="https://blog.csdn.net/chenmingxu438521/article/details/94485695">SpringBoot配置方式</a></p>
<h2 id="6-xxl-job（常用：分布式定时任务主流）"><a href="#6-xxl-job（常用：分布式定时任务主流）" class="headerlink" title="6.xxl-job（常用：分布式定时任务主流）"></a>6.xxl-job（常用：分布式定时任务主流）</h2><p>xxl-job 是大众点评（许雪里）开发的一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，<code>开箱即用</code>。</p>
<p>xxl-job 框架对 quartz 进行了扩展，使用 mysql 数据库存储数据，并且内置jetty作为 RPC服务调用。</p>
<p>具体配置可以参考之前本人写的【<a href="https://foamtomato.github.io/2022/02/13/%E5%88%9D%E6%8E%A2xxljob/">初探xxljob</a>】</p>
<p>优缺点：</p>
<ul>
<li>优点：有界面管理定时任务，支持弹性扩容缩容、动态分片、故障转移、失败报警等功能。它的功能非常强大，很多大厂在用，可以满足绝大多数业务场景。</li>
<li>缺点：和 quartz 一样，通过数据库分布式锁，来控制任务不能重复执行。在任务非常多的情况下，有一些性能问题。</li>
</ul>
<h1 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h1><p>在前面提到<code>Timer</code>/<code>ScheduledExecutorService</code>/<code>SpringTask(@Schedule)</code>都是单机的，但我们一旦上了生产环境，应用部署<strong>往往</strong>都是集群模式的。</p>
<p>在集群下，我们一般是希望<strong>某个定时任务</strong>只在某台机器上执行，那这时候，单机实现的定时任务就不太好处理了。</p>
<p><code>Quartz</code>是有<strong>集群部署</strong>方案的，所以有的人会利用<strong>数据库行锁</strong>或者使用<strong>Redis分布式锁</strong>来自己实现定时任务跑在某一台<strong>应用机器</strong>上；做肯定是能做的，包括有些挺出名的分布式定时任务框架也是这样做的，能解决问题。</p>
<p>但我们遇到的问题不单单只有这些，比如我想要支持<strong>容错</strong>功能（失败重试）、<strong>分片</strong>功能、<strong>手动触发</strong>一次任务、有一个比较好的管理定时任务的<strong>后台界面</strong>、<strong>路由</strong>负载均衡等等。这些功能，就是作为「<strong>分布式定时任务框架</strong>」所具备的。</p>
<p>分布式定时任务框架又可以分成了<strong>两个流派</strong>：中心化和去中心化</p>
<ul>
<li>所谓的「中心化」指的是：调度器和执行器<strong>分离</strong>，调度器统一进行调度，通知执行器去执行定时任务</li>
<li>所谓的「去中心化」指的是：调度器和执行器<strong>耦合</strong>，自己调度自己执行</li>
</ul>
<p>对于「中心化」流派来说，存储相关的信息很可能是在<strong>数据库</strong>（DataBase），而我们引入的<code>client</code>包实际上就是<strong>执行器</strong>相关的代码。调度器<strong>实现了任务调度</strong>的逻辑，<strong>远程调用</strong>执行器触发对应的逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83ab16a6eb9d4e3aaa342834ba0caf5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h1 id="谈谈定时任务使用场景"><a href="#谈谈定时任务使用场景" class="headerlink" title="谈谈定时任务使用场景"></a>谈谈定时任务使用场景</h1><p>我现在公司对于定时任务的主要使用场景是更新缓存，清洗数据，定时推送，定时拉单等等</p>
<p>先说说更新缓存：就是每隔一段时间去执行操作，可能一天只需要更新一次当天的缓存数据，一般会选择放在凌晨人流量少的时候执行。</p>
<p>清洗数据和定时拉单就比较像，会比如每间隔15分钟去进行一次扫表，看看有没有需要进行执行的流程</p>
<p>定时推送就是你想的那样，定时推送消息或者定时执行代码的开关</p>
<p>对于以上的操作，我们可以分为两种，全量更新和增量更新</p>
<p><code>全量更新</code>：这个比较常用，就是一次性全部查询出来，然后一次性更新到缓存里面去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zxMachineBuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1.查询需要缓存的数据</span></span><br><span class="line">    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax();</span><br><span class="line">    <span class="comment">// 2.拼接存储格式</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Tax tax:taxs)&#123;</span><br><span class="line">        ……</span><br><span class="line">        map.put(tax.getPindex(),tax);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3.更新到redis</span></span><br><span class="line">    redisService.batchPutInPipelined(map,<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：因为以上使用的是有过期时间的，如果正常跑的话一般会先删后增，如果是redis的话可以直接全部覆盖（使用场景一般是初始化的时候或者数据重跑）</p>
<p><code>增量更新</code>：增量的基础就是全量，先全量更新后，再用增量方式同步更新，一般利用节点或者状态去进行更新</p>
<p>我们常用的更新方式</p>
<p><code>根据状态更新</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zxMachineBuild</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1.查询需要增量的数据</span></span><br><span class="line">    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax(type);</span><br><span class="line">    <span class="comment">// 2.拼接存储格式</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Tax tax:taxs)&#123;</span><br><span class="line">        ……</span><br><span class="line">        map.put(tax.getPindex(),tax);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3.更新到redis，根据数据判断使用过期还是精准删除</span></span><br><span class="line">    redisService.batchPutInPipelined(map,<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">    <span class="comment">// 4.更新状态</span></span><br><span class="line">    tConfigPolicyMapper.updateTConfigType(taxs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>根据节点更新</code>:假设我使用redis来存储我的节点（一般会使用id作为节点，以下例子使用时间节点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zxMachineBuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取上次更新的时间节点</span></span><br><span class="line">    <span class="keyword">long</span> nodeTime = redisService.getNodeTime();</span><br><span class="line">	<span class="comment">// 获取在该时间节点之后的数据（根据时间排序）</span></span><br><span class="line">    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax(nodeTime);</span><br><span class="line">    <span class="comment">// 拼接存储格式</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Tax tax:taxs)&#123;</span><br><span class="line">        ……</span><br><span class="line">        map.put(tax.getPindex(),tax);</span><br><span class="line">        <span class="comment">// 如果不根据时间排序就比较获取</span></span><br><span class="line">        <span class="keyword">if</span>(tax.getCreateTime() != <span class="keyword">null</span> &amp;&amp; tax.getCreateTime() &gt; nodeTime)&#123;</span><br><span class="line">			nodeTime = tax.getCreateTime();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3.更新到redis，根据数据判断使用过期还是精准删除</span></span><br><span class="line">    redisService.batchPutInPipelined(map,<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">    <span class="comment">// 4.更新时间节点到redis（获取最后一个的时间节点）</span></span><br><span class="line">    redisService.updateNodeTime(nodeTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>进阶</code>（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zxMachineBuild</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 随机一个uuid</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    tConfigPolicyMapper.Lock(uuid);</span><br><span class="line">	<span class="comment">// 查询提前锁定好的数据</span></span><br><span class="line">    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax(uuid);</span><br><span class="line">    <span class="comment">// 拼接存储格式</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Tax tax:taxs)&#123;</span><br><span class="line">        ……</span><br><span class="line">        map.put(tax.getPindex(),tax);</span><br><span class="line">        <span class="comment">// 如果不根据时间排序就比较获取</span></span><br><span class="line">        <span class="keyword">if</span>(tax.getCreateTime() != <span class="keyword">null</span> &amp;&amp; tax.getCreateTime() &gt; nodeTime)&#123;</span><br><span class="line">			nodeTime = tax.getCreateTime();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 更新到redis，根据数据判断使用过期还是精准删除</span></span><br><span class="line">    redisService.batchPutInPipelined(map,<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">    <span class="comment">// 更新锁定状态为已跑</span></span><br><span class="line">    tConfigPolicyMapper.updateNodeTime(taxs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以上方式的好处就是可以直接先锁定自己需要跑的部分，防止其他的定时任务抢占</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 取t_pao_lowprice_taobao数据出来，设置state<span class="operator">=</span>‘L’ 锁住</span><br><span class="line">update [t_pao_lowprice_taobao] <span class="keyword">set</span> lockname<span class="operator">=</span><span class="string">&#x27;guid&#x27;</span>,locktime<span class="operator">=</span>GETDATE(),state<span class="operator">=</span><span class="string">&#x27;L&#x27;</span> </span><br><span class="line"><span class="keyword">from</span> [t_pao_lowprice_taobao] a <span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> top <span class="number">2</span> id <span class="keyword">from</span> [t_pao_lowprice_taobao] <span class="keyword">where</span> lockname <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">and</span> state<span class="operator">=</span><span class="string">&#x27;N&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> createtime <span class="keyword">asc</span>) </span><br><span class="line">b <span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## lockname【对应代码的uuid】 状态为state<span class="operator">=</span>‘L’ 获取需要跑的数据，开线程去跑</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [t_pao_lowprice_taobao] <span class="keyword">where</span> lockname<span class="operator">=</span><span class="string">&#x27;guid&#x27;</span> <span class="keyword">and</span> state<span class="operator">=</span><span class="string">&#x27;L&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能在个人项目中，对于定时任务的需求没有那么多，不会去重视这一块，但是在实际工作中，定时任务往往扮演着重要的角色</p>
<p>不同的定时任务有不同的优缺点，往往我们去选择适合自己的那种方式，就需要对于其种类有一定的了解，怎样才能更高效的去进行开发，尽量避免使用到一半因为其底层设计的原因导致BUG。</p>
<p>现在基本也使用<code>E-Job(ElasticJob)</code>或者<code>X-Job(XXLJob)</code>这种分布式定时任务，它们都有广泛的用户基础和完整的技术文档</p>
<ul>
<li>X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用</li>
<li>E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用</li>
</ul>
<p>单机的定时任务现在基本不推荐使用了，维护起来比较麻烦</p>
<p>对于定时任务，个人理解程度有限，使用的场景往往更加复杂不能每点都考虑到，欢迎大家能提出自己的想法</p>
<p>比如分布式定时任务下如何去保证事务的一致性，单机定时任务又如何去保证数据不重复等等场景都需要去挖掘……</p>
<p>参考指南：</p>
<ul>
<li><a href="https://www.jianshu.com/p/4385a2df73f3">什么是定时任务</a></li>
<li><a href="https://blog.csdn.net/Java_Pluto/article/details/117352506">十种常用定时任务</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/313595122">Springboot定时任务以及优缺点</a></li>
<li><a href="https://blog.csdn.net/userlhj/article/details/89510837">Spring集成Quartz定时器</a></li>
<li><a href="https://juejin.cn/post/7078829903558213639">为什么要用分布式定时任务</a></li>
<li><a href="https://juejin.cn/post/6987191113689858084">分布式定时任务框架选型</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>aop的简单使用</title>
    <url>/2022/04/25/0.1.2aop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p> AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，和 OOP（面向对象编程）类似，也是一种编程思想</p>
</blockquote>
<p>AOP 采取横向抽取机制（动态代理），取代了传统纵向继承机制的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。主要作用是分离功能性需求和非功能性需求，使开发人员可以集中处理某一个关注点或者横切逻辑，减少对业务代码的侵入，增强代码的可读性和可维护性。</p>
<p><code>AOP 的作用就是保证开发者在不修改源代码的前提下，为系统中的业务组件添加某种通用功能</code>AOP 就是代理模式的典型应用。</p>
<p>目前最流行的 AOP 框架有两个，分别为 <strong>Spring AOP 和 AspectJ</strong></p>
<ul>
<li>Spring AOP 是基于 AOP 编程模式的一个框架，它能够有效的减少系统间的重复代码，达到松耦合的目的。Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。有两种实现方式：基于接口的 JDK 动态代理和基于继承的 CGLIB 动态代理</li>
<li>AspectJ 是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入</li>
</ul>
<h2 id="spring4-0执行顺序"><a href="#spring4-0执行顺序" class="headerlink" title="spring4.0执行顺序"></a>spring4.0执行顺序</h2><p><strong>正常执行顺序</strong></p>
<blockquote>
<p>around开始 – before – 方法调用 –  around结束 – after 执行 – afterReturning 执行</p>
</blockquote>
<p><strong>异常执行顺序</strong></p>
<blockquote>
<p>around开始 – before – 方法调用 –  around结束 – after 执行 – afterThrowing 执行</p>
</blockquote>
<h2 id="spring5-28执行顺序"><a href="#spring5-28执行顺序" class="headerlink" title="spring5.28执行顺序"></a>spring5.28执行顺序</h2><p><strong>正常执行顺序</strong></p>
<blockquote>
<p>around开始 – before – 方法调用 – afterReturning 执行 – after 执行 –  around结束</p>
</blockquote>
<p><strong>异常执行顺序</strong></p>
<blockquote>
<p>around开始 – before – 方法调用 – afterThrowing 执行 – after 执行 –  around结束</p>
</blockquote>
<h2 id="普通使用（直接匹配包）"><a href="#普通使用（直接匹配包）" class="headerlink" title="普通使用（直接匹配包）"></a>普通使用（直接匹配包）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> dw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MyAop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> AOP 各个通知使用示例：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableAspectJAutoProxy</span> ： 默认已开启不需要再添加响应的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/15 0:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点 (一个切面类中可以定义多个切入点)</span></span><br><span class="line"><span class="comment">     * 拦截所有 com.dw.study.controller 包以及子包下所有类的所有方案</span></span><br><span class="line"><span class="comment">     * 第一个 * 表示所有返回值</span></span><br><span class="line"><span class="comment">     * 第二个 * 表示所有类</span></span><br><span class="line"><span class="comment">     * 第三个 * 表示所有的方法名</span></span><br><span class="line"><span class="comment">     * 两个 .. 表示当前包以及子包</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.dw.study.controller..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span> </span>&#123;&#125;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，目标方法调用前被调用</span></span><br><span class="line"><span class="comment">     * 除<span class="doctag">@Around</span>外，每个方法里都可以加或者不加参数JoinPoint。</span></span><br><span class="line"><span class="comment">     * JoinPoint包含了类名、被切面的方法名、参数等属性。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;aspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AOP before 执行... ：参数类型：&#123;&#125;&quot;</span>, joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知，目标方法执行完之后执行</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@After(value = &quot;aspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AOP after 执行...  ：&#123;&#125;&quot;</span>, joinPoint.toLongString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置返回通知</span></span><br><span class="line"><span class="comment">     * 如果参数中的第一个参数为JoinPoint，则第二个参数为返回值的信息</span></span><br><span class="line"><span class="comment">     * 如果参数中的第一个参数不为JoinPoint，则第一个参数为returning中对应的参数</span></span><br><span class="line"><span class="comment">     * returning 只有目标方法返回值与通知方法具有相应参数类型时才能执行后置返回通知，否则不执行</span></span><br><span class="line"><span class="comment">     * 除了使用上面定义好的切面aspect()， 也可以直接使用表达式。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.dw.study.controller..*.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AOP afterReturning 执行...  ：返回结果：&#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值。</span></span><br><span class="line"><span class="comment">     * 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型</span></span><br><span class="line"><span class="comment">     * 2：proceedingJoinPoint.proceed() 执行被代理的方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;aspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;AOP around开始... 执行方法... ：&#123;&#125;&quot;</span>, proceedingJoinPoint.getSignature().getName());</span><br><span class="line">            Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">            log.info(<span class="string">&quot;AOP around结束... 执行方法... ：&#123;&#125;&quot;</span>, proceedingJoinPoint.getSignature().getName());</span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;AOP around 执行错误... error ：&#123;&#125;&quot;</span>, throwable.getMessage());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;执行around出错。。。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置异常通知</span></span><br><span class="line"><span class="comment">     * 定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；</span></span><br><span class="line"><span class="comment">     * throwing 只有目标方法抛出的异常与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;aspect()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;AOP afterThrowing 执行... , msg : &#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> NullPointerException)</span><br><span class="line">            log.info(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义注解匹配-无参"><a href="#自定义注解匹配-无参" class="headerlink" title="自定义注解匹配(无参)"></a>自定义注解匹配(无参)</h2><h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodAspect &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义切面"><a href="#2-定义切面" class="headerlink" title="2.定义切面"></a>2.定义切面</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于注解定义切入点 2</span></span><br><span class="line"><span class="comment">     * 对于注解了 <span class="doctag">@MethodAspect</span>的方法进行拦截</span></span><br><span class="line"><span class="comment">     * 表示标注了特定注解的目标方法链接点。如<span class="doctag">@annotation</span>(com.dw.study.TestAnnotation)表示任何标注了<span class="doctag">@TestAnnotation</span>注解的目标类方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.dw.study.customAnnotation.MethodAspect)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotationAspect</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，目标方法调用前被调用</span></span><br><span class="line"><span class="comment">     * 除<span class="doctag">@Around</span>外，每个方法里都可以加或者不加参数JoinPoint。</span></span><br><span class="line"><span class="comment">     * JoinPoint包含了类名、被切面的方法名、参数等属性。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;testMyAnnotationAspect()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AOP before 执行... ：参数类型：&#123;&#125;&quot;</span>, joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-扫描"><a href="#3-扫描" class="headerlink" title="3.扫描"></a>3.扫描</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="meta">@MethodAspect</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SpringBoot-HelloWorld&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义注解匹配-带参"><a href="#自定义注解匹配-带参" class="headerlink" title="自定义注解匹配(带参)"></a>自定义注解匹配(带参)</h2><h3 id="1-自定义注解-1"><a href="#1-自定义注解-1" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodAspect &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">default</span> description&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义切面-1"><a href="#2-定义切面-1" class="headerlink" title="2.定义切面"></a>2.定义切面</h3><p><strong><code>如果需要获取@annotation中的值，需要和方法参数名相同</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于注解定义切入点 2</span></span><br><span class="line"><span class="comment">     * 对于注解了 <span class="doctag">@MethodAspect</span>的方法进行拦截</span></span><br><span class="line"><span class="comment">     * 表示标注了特定注解的目标方法链接点。如<span class="doctag">@annotation</span>(com.dw.study.TestAnnotation)表示任何标注了<span class="doctag">@TestAnnotation</span>注解的目标类方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.dw.study.customAnnotation.MethodAspect)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotationAspect</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，目标方法调用前被调用</span></span><br><span class="line"><span class="comment">     * 除<span class="doctag">@Around</span>外，每个方法里都可以加或者不加参数JoinPoint。</span></span><br><span class="line"><span class="comment">     * JoinPoint包含了类名、被切面的方法名、参数等属性。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@annotation</span>中的值，需要和方法参数名相同(重要)</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;testMyAnnotationAspect() &amp;&amp; @annotation(methodAspect)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint, MethodAspect methodAspect)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AOP before 执行... ：参数类型：&#123;&#125;&quot;</span>, joinPoint.getArgs());</span><br><span class="line">        log.info(<span class="string">&quot;before-value== &quot;</span>+ methodAspect.value() + <span class="string">&quot;before-description== &quot;</span> + methodAspect.description());</span><br><span class="line">        <span class="comment">// 接收到请求，记录请求内容</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">// 记录下请求内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL : &quot;</span> + request.getRequestURL().toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;HTTP_METHOD : &quot;</span> + request.getMethod());</span><br><span class="line">        System.out.println(<span class="string">&quot;IP : &quot;</span> + request.getRemoteAddr());</span><br><span class="line">        System.out.println(<span class="string">&quot;CLASS_METHOD : &quot;</span> + joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;ARGS : &quot;</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值。</span></span><br><span class="line"><span class="comment">     * 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型</span></span><br><span class="line"><span class="comment">     * 2：proceedingJoinPoint.proceed() 执行被代理的方法</span></span><br><span class="line"><span class="comment">     *   <span class="doctag">@annotation</span>中的值，需要和方法参数名相同</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;testMyAnnotationAspect() &amp;&amp; @annotation(methodAspect)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint, MethodAspect methodAspect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;AOP around开始... 执行方法... ：&#123;&#125;&quot;</span>, proceedingJoinPoint.getSignature().getName());</span><br><span class="line">            log.info(<span class="string">&quot;around-value== &quot;</span>+ methodAspect.value() + <span class="string">&quot;around-description== &quot;</span> + methodAspect.description());</span><br><span class="line">            Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">            log.info(<span class="string">&quot;AOP around结束... 执行方法... ：&#123;&#125;&quot;</span>, proceedingJoinPoint.getSignature().getName());</span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;AOP around 执行错误... error ：&#123;&#125;&quot;</span>, throwable.getMessage());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;执行around出错。。。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附文"><a href="#附文" class="headerlink" title="附文"></a>附文</h2><p>为了更好地理解 AOP，我们需要了解一些它的相关术语。这些专业术语并不是 Spring 特有的，有些也同样适用于其它 AOP 框架，如 AspectJ。</p>
<p>它们的含义如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Joinpoint（连接点）</td>
<td align="center">指那些被拦截到的点，在 Spring 中，指可以被动态代理拦截目标类的方法。</td>
</tr>
<tr>
<td align="center">Pointcut（切入点）</td>
<td align="center">指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。</td>
</tr>
<tr>
<td align="center">Advice（通知）</td>
<td align="center">指拦截到 Joinpoint 之后要做的事情，即对切入点增强的内容。</td>
</tr>
<tr>
<td align="center">Target（目标）</td>
<td align="center">指代理的目标对象。</td>
</tr>
<tr>
<td align="center">Weaving（植入）</td>
<td align="center">指把增强代码应用到目标上，生成代理对象的过程。</td>
</tr>
<tr>
<td align="center">Proxy（代理）</td>
<td align="center">指生成的代理对象。</td>
</tr>
<tr>
<td align="center">Aspect（切面）</td>
<td align="center">切入点和通知的结合。</td>
</tr>
</tbody></table>
<p>Advice 直译为通知，也有的资料翻译为“增强处理”，共有 5 种类型，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">通知</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">before（前置通知）</td>
<td align="center">通知方法在目标方法调用之前执行</td>
</tr>
<tr>
<td align="center">after（后置通知）</td>
<td align="center">通知方法在目标方法返回或异常后调用</td>
</tr>
<tr>
<td align="center">after-returning（返回后通知）</td>
<td align="center">通知方法会在目标方法返回后调用</td>
</tr>
<tr>
<td align="center">after-throwing（抛出异常通知）</td>
<td align="center">通知方法会在目标方法抛出异常后调用</td>
</tr>
<tr>
<td align="center">around（环绕通知）</td>
<td align="center">通知方法会将目标方法封装起来</td>
</tr>
</tbody></table>
<h3 id="execution表达式："><a href="#execution表达式：" class="headerlink" title="execution表达式："></a>execution表达式：</h3><p>用于匹配方法执行的连接点，属于方法级别， 语法： <code>execution(修饰符 返回值类型 方法名（参数）异常)</code></p>
<table>
<thead>
<tr>
<th align="center"><strong>语法参数</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>修饰符</strong></td>
<td align="center"><strong>可选，如public，protected，写在返回值前，任意修饰符填<code>*</code>号就可以</strong></td>
</tr>
<tr>
<td align="center"><strong>返回值类型</strong></td>
<td align="center"><strong><code>必选</code>，可以使用<code>*</code>来代表任意返回值</strong></td>
</tr>
<tr>
<td align="center"><strong>方法名</strong></td>
<td align="center"><strong><code>必选</code>，可以用<code>*</code>来代表任意方法</strong></td>
</tr>
<tr>
<td align="center"><strong>参数</strong></td>
<td align="center"><strong><code>必选， ()</code>代表是没有参数，<code>(..)</code>代表是匹配任意数量，任意类型的参数，当然也可以指定类型的参数进行匹配，如要接受一个String类型的参数，则<code>(java.lang.String)</code>, 任意数量的String类型参数：<code>(java.lang.String..)</code>等等。。。</strong></td>
</tr>
<tr>
<td align="center"><strong>异常</strong></td>
<td align="center"><strong>可选，语法：<code>throws 异常</code>，异常是完整带包名，可以是多个，用逗号分隔</strong></td>
</tr>
</tbody></table>
<p><strong>execution()表达式案例</strong>：</p>
<ul>
<li><strong>拦截</strong><code>com.dw.study</code><strong>包下的所有子包里的任意类的任意方法</strong><br><strong><code>execution(* com.dw.study..*.*(..))</code></strong></li>
<li><strong>拦截</strong><code>com.dw.study</code><strong>.Test2Controller下的任意方法</strong><br><strong><code>execution(* **</code>com.dw.study<code>**.Test2Controller.*(..))</code></strong></li>
<li><strong>拦截任何修饰符为public的方法</strong><br><strong><code>execution(public * * (..))</code></strong></li>
<li><strong>拦截</strong><code>com.dw.study</code><strong>下的所有子包里的以ok开头的方法</strong><br><strong><code>execution(* **</code>com.dw.study<code>**..*.ok* (..))</code></strong></li>
</ul>
<h3 id="JoinPoint"><a href="#JoinPoint" class="headerlink" title="JoinPoint"></a><strong>JoinPoint</strong></h3><p>JoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象。 除 <strong>@Around</strong> 外，每个通知的方法里都可以加或者不加参数JoinPoint。JoinPoint包含了类名、被切面的方法名、参数等属性。@Around 参数必须为 ProceedingJoinPoint</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Signature getSignature();</td>
<td align="center">获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息</td>
</tr>
<tr>
<td align="center">Object[] getArgs();</td>
<td align="center">获取传入目标方法的参数对象</td>
</tr>
<tr>
<td align="center">Object getTarget();</td>
<td align="center">获取被代理的对象</td>
</tr>
<tr>
<td align="center">Object getThis();</td>
<td align="center">获取代理对象</td>
</tr>
</tbody></table>
<h3 id="ProceedingJoinPoint"><a href="#ProceedingJoinPoint" class="headerlink" title="ProceedingJoinPoint"></a><strong>ProceedingJoinPoint</strong></h3><p> ProceedingJoinPoint对象是JoinPoint 的子接口, 该对象只用在@Around的切面方法中：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object proceed() throws Throwable</td>
<td align="center">执行目标方法</td>
</tr>
<tr>
<td align="center">Object proceed(Object[] var1) throws Throwable</td>
<td align="center">传入的新的参数去执行目标方法</td>
</tr>
</tbody></table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>AOP 是 Spring 的核心之一，在 Spring 中经常会使用 AOP 来简化编程。</p>
<p> 在 Spring 框架中使用 AOP 主要有以下优势：</p>
<ul>
<li>提供声明式企业服务，特别是作为 EJB 声明式服务的替代品。最重要的是，这种服务是声明式事务管理。</li>
<li>允许用户实现自定义切面。在某些不适合用 OOP 编程的场景中，采用 AOP 来补充。</li>
<li>可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时也提高了开发效率。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.cnblogs.com/dw3306/p/15077474.html"><strong>Spring AOP：基于AspectJ注解开发</strong></a></p>
</li>
<li><p><a href="https://blog.csdn.net/q982151756/article/details/80513340?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_default&utm_relevant_index=2">细说SpringAop详解</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/395709988">https://zhuanlan.zhihu.com/p/395709988</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>mycat简单介绍</title>
    <url>/2022/04/17/0.1.5mycat%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>如今随着互联网的发展，数据的量级也是成指数式的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求,这个时候NoSQL的出现暂时解决了这一危机。<code>它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升</code>。但是，在有些场合NoSQL一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候NoSQL肯定是无法满足的，所以还是需要使用关系性数据库。如何使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储，为应对此问题就出现了——MyCat 。</p>
</blockquote>
<p>MyCAT的目标是：低成本的将现有的单机数据库和应用平滑迁移到”云”端，解决海量数据存储和业务规模迅速增长情况下的数据存储和访问的瓶颈问题 。</p>
<p>Mycat 背后是阿里曾经开源的知名产品——Cobar，Cobar 的核心功能和优势是 MySQL 数据库分片</p>
<p>相对于cobar的优势</p>
<ul>
<li>对 cobar 的代码进行了彻底的重构，Mycat在I/O方面进行了重大改进,将原来的BIO改成了NIO, 并发量有大幅提高 </li>
<li>增加了对Order By、Group By、limit等聚合功能的支持，同时兼容绝大多数数据库成为通用的数据库中间件</li>
<li>对于开发人员来说根本感觉不到mycat的存在</li>
</ul>
<p>MyCat发展到目前的版本，已经不是一个单纯的MySQL代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库，也支持MongoDB这种新型NoSQL方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在MyCat里，都是一个传统的数据库表，支持标准的SQL语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度</p>
<h2 id="MyCat使用场景"><a href="#MyCat使用场景" class="headerlink" title="MyCat使用场景"></a>MyCat使用场景</h2><h3 id="1-高可用性与MySQL读写分离"><a href="#1-高可用性与MySQL读写分离" class="headerlink" title="1.高可用性与MySQL读写分离"></a>1.高可用性与MySQL读写分离</h3><p>高可用：利用MyCat可以轻松实现热备份，当一台服务器停机时，可以由集群中的另一台服务器自动接管业务，无需人工干预，从而保证高可用。</p>
<p>读写分离：通过MySQL数据库的binlog日志完成主从复制，并可以通过MyCat轻松实现读写分离，实现insert、update、delete走主库，而在select时走从库，从而缓解单台服务器的访问压力。</p>
<h3 id="2-业务数据分级存储保障"><a href="#2-业务数据分级存储保障" class="headerlink" title="2. 业务数据分级存储保障"></a>2. 业务数据分级存储保障</h3><p>企业的数据量总是无休止的增长，这些数据的格式不一样，访问效率不一样，重要性也不一样。可以针对不同级别的数据，采用不同的存储设备，通过分级存储管理软件实现数据客体在存储设备之间自动迁移及自动访问切换</p>
<h3 id="3-大表水平拆分，集群并行计算"><a href="#3-大表水平拆分，集群并行计算" class="headerlink" title="3.大表水平拆分，集群并行计算"></a>3.大表水平拆分，集群并行计算</h3><p>数据切分是MyCat的核心功能，是指通过某种特定的条件，将存放在同一个数据库的数据，分散存储在多个数据库中，以达到分散单台设备负载的效果。当数据库量超过800万行且需要做分片时，就可以考虑使用MyCat实现数据切分。</p>
<h3 id="4-数据库路由器"><a href="#4-数据库路由器" class="headerlink" title="4.数据库路由器"></a>4.数据库路由器</h3><p>MyCat基于MySQL实例的连接池复用机制，可以让每个应用最大程度共享一个MySQL实例的所有连接池，让数据库的并发访问能力大大提升。</p>
<h3 id="5-整合多种数据源"><a href="#5-整合多种数据源" class="headerlink" title="5.整合多种数据源"></a>5.整合多种数据源</h3><p>当一个项目中使用了多个数据库（Oracle，MySQL，SQL Server,PostgreSQL），并配置了多个数据源，操作起来就比较繁琐，这时就可以使用MyCat进行整合，最终我们的应用程序只需要访问一个数据源即可</p>
<h2 id="MyCat原理"><a href="#MyCat原理" class="headerlink" title="MyCat原理"></a>MyCat原理</h2><blockquote>
<p>MyCat相当于MySQL的Server层</p>
<p>MySQL相当于MyCat的存储层</p>
</blockquote>
<ul>
<li>拦截：拦截用户发送的sql</li>
<li>分析：分析分片，路由分析，读写分离分析，缓存分析</li>
<li>分发：根据分片规则分发给对应的数据源</li>
<li>拼接：把各数据源返回的结果聚合</li>
</ul>
<p><code>MyCat对于研发来说是透明的</code></p>
<h2 id="MyCat使用"><a href="#MyCat使用" class="headerlink" title="MyCat使用"></a>MyCat使用</h2><p>下载地址: <a href="https://github.com/MyCATApache/Mycat-download">https://github.com/MyCATApache/Mycat-download</a></p>
<p>最新下载地址: <a href="http://dl.mycat.io/">http://dl.mycat.io/</a></p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220417203048414.png/" alt="image-20220417203048414"></p>
<h3 id="配置schema-xml"><a href="#配置schema-xml" class="headerlink" title="配置schema.xml"></a>配置schema.xml</h3><blockquote>
<p>schema.xml 作为MyCat中重要的配置文件之一，管理着MyCat的逻辑库、逻辑表以及对应的分片规则、DataNode以及DataSource。弄懂这些配置，是正确使用MyCat的前提。这里就一层层对该文件进行解析。</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>schema</td>
<td>标签用于定义MyCat实例中的逻辑库</td>
</tr>
<tr>
<td>table</td>
<td>标签定义了MyCat中的逻辑表, rule用于指定分片规则，auto-sharding-long的分片规则是按ID值的范围进行分片 1-5000000 为第1片  5000001-10000000 为第2片….  具体设置我们会在第四节中讲解。</td>
</tr>
<tr>
<td>dataNode</td>
<td>标签定义了MyCat中的数据节点，也就是我们通常说所的数据分片。</td>
</tr>
<tr>
<td>dataHost</td>
<td>标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。</td>
</tr>
</tbody></table>
<p>schema.xml文件配置(可根据自己的需求加减配置)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 逻辑库配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逻辑表配置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_TEST&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 数据节点配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 节点主机配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.157:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;itcast&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.158:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;itcast&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.192.159:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;itcast&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置详解</p>
<h4 id="system标签"><a href="#system标签" class="headerlink" title="system标签"></a>system标签</h4><table>
<thead>
<tr>
<th>属性</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>charset</td>
<td>utf8</td>
<td>设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致</td>
</tr>
<tr>
<td>nonePasswordLogin</td>
<td>0,1</td>
<td>0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户</td>
</tr>
<tr>
<td>useHandshakeV10</td>
<td>0,1</td>
<td>使用该选项主要的目的是为了能够兼容高版本的jdbc驱动, 是否采用HandshakeV10Packet来与client进行通信, 1:是, 0:否</td>
</tr>
<tr>
<td>useSqlStat</td>
<td>0,1</td>
<td>开启SQL实时统计, 1 为开启 , 0 为关闭 ;<br />开启之后, MyCat会自动统计SQL语句的执行情况 ;<br />mysql -h 127.0.0.1 -P 9066 -u root -p<br />查看MyCat执行的SQL, 执行效率比较低的SQL , SQL的整体执行情况、读写比例等 ;<br />show @@sql ; show @@sql.slow ; show @@sql.sum ;</td>
</tr>
<tr>
<td>useGlobleTableCheck</td>
<td>0,1</td>
<td>是否开启全局表的一致性检测。1为开启 ，0为关闭 。</td>
</tr>
<tr>
<td>sqlExecuteTimeout</td>
<td>1000</td>
<td>SQL语句执行的超时时间 , 单位为 s ;</td>
</tr>
<tr>
<td>sequnceHandlerType</td>
<td>0,1,2</td>
<td>用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试</td>
</tr>
<tr>
<td>sequnceHandlerPattern</td>
<td>正则表达式</td>
<td>必须带有MYCATSEQ_或者 mycatseq_进入序列匹配流程 注意MYCATSEQ_有空格的情况</td>
</tr>
<tr>
<td>subqueryRelationshipCheck</td>
<td>true,false</td>
<td>子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false</td>
</tr>
<tr>
<td>useCompression</td>
<td>0,1</td>
<td>开启mysql压缩协议 , 0 : 关闭, 1 : 开启</td>
</tr>
<tr>
<td>fakeMySQLVersion</td>
<td>5.5,5.6</td>
<td>设置模拟的MySQL版本号</td>
</tr>
<tr>
<td>defaultSqlParser</td>
<td></td>
<td>由于MyCat的最初版本使用了FoundationDB的SQL解析器, 在MyCat1.3后增加了Druid解析器, 所以要设置defaultSqlParser属性来指定默认的解析器; 解析器有两个 : druidparser 和 fdbparser, 在MyCat1.4之后,默认是druidparser, fdbparser已经废除了</td>
</tr>
<tr>
<td>processors</td>
<td>1,2….</td>
<td>指定系统可用的线程数量, 默认值为CPU核心 x 每个核心运行线程数量; processors 会影响processorBufferPool, processorBufferLocalPercent, processorExecutor属性, 所有, 在性能调优时, 可以适当地修改processors值</td>
</tr>
<tr>
<td>processorBufferChunk</td>
<td></td>
<td>指定每次分配Socket Direct Buffer默认值为4096字节, 也会影响BufferPool长度, 如果一次性获取字节过多而导致buffer不够用, 则会出现警告, 可以调大该值</td>
</tr>
<tr>
<td>processorExecutor</td>
<td></td>
<td>指定NIOProcessor上共享 businessExecutor固定线程池的大小; MyCat把异步任务交给 businessExecutor线程池中, 在新版本的MyCat中这个连接池使用频次不高, 可以适当地把该值调小</td>
</tr>
<tr>
<td>packetHeaderSize</td>
<td></td>
<td>指定MySQL协议中的报文头长度, 默认4个字节</td>
</tr>
<tr>
<td>maxPacketSize</td>
<td></td>
<td>指定MySQL协议可以携带的数据最大大小, 默认值为16M</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>30</td>
<td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟</td>
</tr>
<tr>
<td>txIsolation</td>
<td>1,2,3,4</td>
<td>初始化前端连接的事务隔离级别,默认为 REPEATED_READ , 对应数字为3<br />READ_UNCOMMITED=1;<br />READ_COMMITTED=2;<br />REPEATED_READ=3;<br />SERIALIZABLE=4;</td>
</tr>
<tr>
<td>sqlExecuteTimeout</td>
<td>300</td>
<td>执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;</td>
</tr>
<tr>
<td>serverPort</td>
<td>8066</td>
<td>定义MyCat的使用端口, 默认8066</td>
</tr>
<tr>
<td>managerPort</td>
<td>9066</td>
<td>定义MyCat的管理端口, 默认9066</td>
</tr>
</tbody></table>
<h3 id="server-xml配置"><a href="#server-xml配置" class="headerlink" title="server.xml配置"></a>server.xml配置</h3><blockquote>
<p>server.xml几乎保存了所有mycat需要的系统配置信息。最常用的是在此配置用户名、密码及权限。在system中添加UTF-8字符集设置，否则存储中文会出现问号</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;charset&quot;</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改user的设置 ,  我们这里为 ITCAST 设置了两个用户 : </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="user标签"><a href="#user标签" class="headerlink" title="user标签"></a>user标签</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITCAST<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;benchmark&quot;</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usingDecrypt&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 		</span></span><br><span class="line"><span class="comment">    &lt;privileges check=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">            &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">            &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">    &lt;/privileges&gt;		</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>user标签主要用于定义登录MyCat的用户和权限 :</p>
<p>1). &lt;user name=”root” defaultAccount=”true”&gt; : name 属性用于声明用户名 ;</p>
<p>2). &lt;property name=”password”&gt;123456&lt;/property&gt; : 指定该用户名访问MyCat的密码 ;</p>
<p>3). &lt;property name=”schemas”&gt;ITCAST&lt;/property&gt; : 能够访问的逻辑库, 多个的话, 使用 “,” 分割</p>
<p>4). &lt;property name=”readOnly”&gt;true&lt;/property&gt; : 是否只读</p>
<p>5). &lt;property name=”benchmark”&gt;11111&lt;/property&gt; : 指定前端的整体连接数量 , 0 或不设置表示不限制 </p>
<p>6). &lt;property name=”usingDecrypt”&gt;0&lt;/property&gt; : 是否对密码加密默认 0 否 , 1 是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp Mycat-server-1.6.7.3-release.jar io.mycat.util.DecryptUtil 0:root:123456</span><br></pre></td></tr></table></figure>

<p>7). &lt;privileges check=”false”&gt;</p>
<p>A. 对用户的 schema 及 下级的 table 进行精细化的 DML 权限控制; </p>
<p>B. privileges 节点中的 check 属性是用 于标识是否开启 DML 权限检查， 默认 false 标识不检查，当然 privileges 节点不配置，等同 check=false, 由于 Mycat 一个用户的 schemas 属性可配置多个 schema ，所以 privileges 的下级节点 schema 节点同样 可配置多个，对多库多表进行细粒度的 DML 权限控制;</p>
<p>C. 权限修饰符四位数字(0000 - 1111)，对应的操作是 IUSD ( 增，改，查，删 )。同时配置了库跟表的权限，就近原则。以表权限为准。</p>
<h4 id="firewall-标签"><a href="#firewall-标签" class="headerlink" title="firewall 标签"></a>firewall 标签</h4><p>firewall标签用来定义防火墙；firewall下whitehost标签用来定义 IP白名单 ，blacklist用来定义 SQL黑名单。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 白名单配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">host</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 黑名单配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span> <span class="attr">check</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;selelctAllow&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>黑名单拦截明细配置:</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>selelctAllow</td>
<td>true</td>
<td>是否允许执行 SELECT 语句</td>
</tr>
<tr>
<td>selectAllColumnAllow</td>
<td>true</td>
<td>是否允许执行 SELECT * FROM T 这样的语句。如果设置为 false，不允许执行 select * from t，但可以select * from (select id, name from t) a。这个选项是防御程序通过调用 select * 获得数据表的结构信息。</td>
</tr>
<tr>
<td>selectIntoAllow</td>
<td>true</td>
<td>SELECT 查询中是否允许 INTO 字句</td>
</tr>
<tr>
<td>deleteAllow</td>
<td>true</td>
<td>是否允许执行 DELETE 语句</td>
</tr>
<tr>
<td>updateAllow</td>
<td>true</td>
<td>是否允许执行 UPDATE 语句</td>
</tr>
<tr>
<td>insertAllow</td>
<td>true</td>
<td>是否允许执行 INSERT 语句</td>
</tr>
<tr>
<td>replaceAllow</td>
<td>true</td>
<td>是否允许执行 REPLACE 语句</td>
</tr>
<tr>
<td>mergeAllow</td>
<td>true</td>
<td>是否允许执行 MERGE 语句，这个只在 Oracle 中有用</td>
</tr>
<tr>
<td>callAllow</td>
<td>true</td>
<td>是否允许通过 jdbc 的 call 语法调用存储过程</td>
</tr>
<tr>
<td>setAllow</td>
<td>true</td>
<td>是否允许使用 SET 语法</td>
</tr>
<tr>
<td>truncateAllow</td>
<td>true</td>
<td>truncate 语句是危险，缺省打开，若需要自行关闭</td>
</tr>
<tr>
<td>createTableAllow</td>
<td>true</td>
<td>是否允许创建表</td>
</tr>
<tr>
<td>alterTableAllow</td>
<td>true</td>
<td>是否允许执行 Alter Table 语句</td>
</tr>
<tr>
<td>dropTableAllow</td>
<td>true</td>
<td>是否允许修改表</td>
</tr>
<tr>
<td>commentAllow</td>
<td>false</td>
<td>是否允许语句中存在注释，Oracle 的用户不用担心，Wall 能够识别 hints和注释的区别</td>
</tr>
<tr>
<td>noneBaseStatementAllow</td>
<td>false</td>
<td>是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽 DDL。</td>
</tr>
<tr>
<td>multiStatementAllow</td>
<td>false</td>
<td>是否允许一次执行多条语句，缺省关闭</td>
</tr>
<tr>
<td>useAllow</td>
<td>true</td>
<td>是否允许执行 mysql 的 use 语句，缺省打开</td>
</tr>
<tr>
<td>describeAllow</td>
<td>true</td>
<td>是否允许执行 mysql 的 describe 语句，缺省打开</td>
</tr>
<tr>
<td>showAllow</td>
<td>true</td>
<td>是否允许执行 mysql 的 show 语句，缺省打开</td>
</tr>
<tr>
<td>commitAllow</td>
<td>true</td>
<td>是否允许执行 commit 操作</td>
</tr>
<tr>
<td>rollbackAllow</td>
<td>true</td>
<td>是否允许执行 roll back 操作</td>
</tr>
<tr>
<td>拦截配置－永真条件</td>
<td></td>
<td></td>
</tr>
<tr>
<td>selectWhereAlwayTrueCheck</td>
<td>true</td>
<td>检查 SELECT 语句的 WHERE 子句是否是一个永真条件</td>
</tr>
<tr>
<td>selectHavingAlwayTrueCheck</td>
<td>true</td>
<td>检查 SELECT 语句的 HAVING 子句是否是一个永真条件</td>
</tr>
<tr>
<td>deleteWhereAlwayTrueCheck</td>
<td>true</td>
<td>检查 DELETE 语句的 WHERE 子句是否是一个永真条件</td>
</tr>
<tr>
<td>deleteWhereNoneCheck</td>
<td>false</td>
<td>检查 DELETE 语句是否无 where 条件，这是有风险的，但不是 SQL 注入类型的风险</td>
</tr>
<tr>
<td>updateWhereAlayTrueCheck</td>
<td>true</td>
<td>检查 UPDATE 语句的 WHERE 子句是否是一个永真条件</td>
</tr>
<tr>
<td>updateWhereNoneCheck</td>
<td>false</td>
<td>检查 UPDATE 语句是否无 where 条件，这是有风险的，但不是SQL 注入类型的风险</td>
</tr>
<tr>
<td>conditionAndAlwayTrueAllow</td>
<td>false</td>
<td>检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永真条件</td>
</tr>
<tr>
<td>conditionAndAlwayFalseAllow</td>
<td>false</td>
<td>检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永假条件</td>
</tr>
<tr>
<td>conditionLikeTrueAllow</td>
<td>true</td>
<td>检查查询条件(WHERE/HAVING 子句)中是否包含 LIKE 永真条件</td>
</tr>
<tr>
<td>其他拦截配置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>selectIntoOutfileAllow</td>
<td>false</td>
<td>SELECT … INTO OUTFILE 是否允许，这个是 mysql 注入攻击的常见手段，缺省是禁止的</td>
</tr>
<tr>
<td>selectUnionCheck</td>
<td>true</td>
<td>检测 SELECT UNION</td>
</tr>
<tr>
<td>selectMinusCheck</td>
<td>true</td>
<td>检测 SELECT MINUS</td>
</tr>
<tr>
<td>selectExceptCheck</td>
<td>true</td>
<td>检测 SELECT EXCEPT</td>
</tr>
<tr>
<td>selectIntersectCheck</td>
<td>true</td>
<td>检测 SELECT INTERSECT</td>
</tr>
<tr>
<td>mustParameterized</td>
<td>false</td>
<td>是否必须参数化，如果为 True，则不允许类似 WHERE ID = 1 这种不参数化的 SQL</td>
</tr>
<tr>
<td>strictSyntaxCheck</td>
<td>true</td>
<td>是否进行严格的语法检测，Druid SQL Parser 在某些场景不能覆盖所有的SQL 语法，出现解析 SQL 出错，可以临时把这个选项设置为 false，同时把 SQL 反馈给 Druid 的开发者。</td>
</tr>
<tr>
<td>conditionOpXorAllow</td>
<td>false</td>
<td>查询条件中是否允许有 XOR 条件。XOR 不常用，很难判断永真或者永假，缺省不允许。</td>
</tr>
<tr>
<td>conditionOpBitwseAllow</td>
<td>true</td>
<td>查询条件中是否允许有”&amp;”、”~”、”|”、”^”运算符。</td>
</tr>
<tr>
<td>conditionDoubleConstAllow</td>
<td>false</td>
<td>查询条件中是否允许连续两个常量运算表达式</td>
</tr>
<tr>
<td>minusAllow</td>
<td>true</td>
<td>是否允许 SELECT * FROM A MINUS SELECT * FROM B 这样的语句</td>
</tr>
<tr>
<td>intersectAllow</td>
<td>true</td>
<td>是否允许 SELECT * FROM A INTERSECT SELECT * FROM B 这样的语句</td>
</tr>
<tr>
<td>constArithmeticAllow</td>
<td>true</td>
<td>拦截常量运算的条件，比如说 WHERE FID = 3 - 1，其中”3 - 1”是常量运算表达式。</td>
</tr>
<tr>
<td>limitZeroAllow</td>
<td>false</td>
<td>是否允许 limit 0 这样的语句</td>
</tr>
<tr>
<td>禁用对象检测配置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tableCheck</td>
<td>true</td>
<td>检测是否使用了禁用的表</td>
</tr>
<tr>
<td>schemaCheck</td>
<td>true</td>
<td>检测是否使用了禁用的 Schema</td>
</tr>
<tr>
<td>functionCheck</td>
<td>true</td>
<td>检测是否使用了禁用的函数</td>
</tr>
<tr>
<td>objectCheck</td>
<td>true</td>
<td>检测是否使用了“禁用对对象”</td>
</tr>
<tr>
<td>variantCheck</td>
<td>true</td>
<td>检测是否使用了“禁用的变量”</td>
</tr>
<tr>
<td>readOnlyTables</td>
<td>空</td>
<td>指定的表只读，不能够在 SELECT INTO、DELETE、UPDATE、INSERT、MERGE 中作为”被修改表”出现</td>
</tr>
</tbody></table>
<h3 id="启动Mycat"><a href="#启动Mycat" class="headerlink" title="启动Mycat"></a>启动Mycat</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/mycat start</span><br><span class="line">bin/mycat stop</span><br><span class="line">bin/mycat status</span><br></pre></td></tr></table></figure>

<p>启动后用mysql链接工具直接连就可以了</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220417203803361.png/" alt="image-20220417203803361"></p>
<h3 id="分片测试"><a href="#分片测试" class="headerlink" title="分片测试"></a>分片测试</h3><p>进入mycat ，执行下列语句创建一个表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TB_TEST (</span><br><span class="line">  id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br></pre></td></tr></table></figure>



<p>我们再查看MySQL的3个库，发现表都自动创建好了</p>
<p>接下来是插入表数据，注意，在写 INSERT 语句时一定要写把字段列表写出来，否则会出现下列错误提示：</p>
<p>错误代码： 1064</p>
<p><code>partition table, insert must provide ColumnList</code></p>
<p>我们试着插入一些数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;goods1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;goods2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;goods3&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们会发现这些数据被写入到第一个节点中了，那什么时候数据会写到第二个节点中呢？</p>
<p>我们插入下面的数据就可以插入第二个节点了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">5000001</span>,<span class="string">&#x27;goods5000001&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>因为我们采用的分片规则是每节点存储500万条数据，所以当ID大于5000000则会存储到第二个节点上。</p>
<p>目前只设置了两个节点，如果数据大于1000万条，会怎么样呢？执行下列语句测试一下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TB_TEST(ID,TITLE) <span class="keyword">VALUES</span>(<span class="number">10000001</span>,<span class="string">&#x27;goods10000001&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="MyCat原理-1"><a href="#MyCat原理-1" class="headerlink" title="MyCat原理"></a>MyCat原理</h3><p>MyCat原理中最重要的一个动词就是 “拦截”, 它拦截了用户发送过来的SQL语句, 首先对SQL语句做一些特定的分析,如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL语句发往后端的真实数据库，并将返回的结果做适当处理，最终再返回给用户，如图所示。</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220417204131752.png/" alt="image-20220417204131752"></p>
<p>在图中,user表被分为三个分片节点dn1、dn2、dn3, 他们分布式在三个MySQL Server(dataHost)上，因此可以使用1-N台服务器来分片,分片规则(sharding rule)为典型的字符串枚举分片规则, 一个规则的定义是分片字段+分片函数。这里的分片字段为 status，分片函数则为字符串枚举方式。</p>
<p>MyCat收到一条SQL语句时，首先解析SQL语句涉及到的表，接着查看此表的定义，如果该表存在分片规则，则获取SQL语句里分片字段的值，并匹配分片函数，得到该SQL语句对应的分片列表，然后将SQL语句发送到相应的分片去执行，最后处理所有分片返回的数据并返回给客户端。以”select * from user where status=’0’” 为例, 查找 status=’0’ ,按照分片函数, ‘0’ 值存放在dn1,于是SQL语句被发送到第一个节点中执行, 然后再将查询的结果返回给用户。</p>
<p>如果发送的SQL语句为 “select * from user where status in (‘0’,’1’)” , 那么SQL语句会被发送到dn1,dn2对应的主机上执行, 然后将结果集合并后输出给用户。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>mycat相对于shardingjdbc可以单独运行，让开发感觉不到它的存在，可以多数据源之间交互，只需要连mycat一个数据源就行了，也可以加监控<code>Mycat-web</code></p>
<p>Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。</p>
<p><img src="https://gitee.com/foam077/images/raw/master/img/image-20220417205909579.png/" alt="image-20220417205909579"></p>
<p>mycat现在强推mycat2，缺点就是文档还在完善中，不够完全，不过相对于mycat1，在配置方面优化的更加简单容易入手了。 建议从mycat1慢慢学上去</p>
]]></content>
      <tags>
        <tag>分库分表</tag>
        <tag>多数据源</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
